<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ì–æ–Ω–∫–∞ –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç–µ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 20px;
    }

    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 12px 24px;
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      border: none;
      border-radius: 25px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }

    .btn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .game-container {
      display: flex;
      gap: 30px;
      justify-content: center;
      flex-wrap: wrap;
      width: 100%;
      max-width: 1400px;
    }

    .player-section {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      border: 1px solid rgba(255,255,255,0.2);
    }

    .player-info {
      margin-bottom: 15px;
      text-align: center;
    }

    .player-name {
      font-size: 1.5em;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .player-status {
      font-size: 1.1em;
      padding: 5px 15px;
      border-radius: 15px;
      display: inline-block;
    }

    .status-ready { background: rgba(52, 152, 219, 0.8); }
    .status-playing { background: rgba(46, 204, 113, 0.8); }
    .status-finished { background: rgba(231, 76, 60, 0.8); }
    .status-winner { background: rgba(241, 196, 15, 0.8); }

    .maze-container {
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .maze {
      display: grid;
      background: #2c3e50;
    }

    .cell {
      width: 12px;
      height: 12px;
      border: 0.5px solid rgba(52, 73, 94, 0.5);
    }

    .wall { background: #34495e; }
    .path { background: #ecf0f1; }
    .start { background: #27ae60; }
    .end { background: #e74c3c; }
    .player { background: #3498db; box-shadow: 0 0 10px #3498db; }
    .computer { background: #e67e22; box-shadow: 0 0 10px #e67e22; }
    .ghost { border-radius: 50%; }
    .ghost-pink { background: #ff79c6; box-shadow: 0 0 8px #ff79c6; }
    .ghost-cyan { background: #8be9fd; box-shadow: 0 0 8px #8be9fd; }
    .ghost-orange { background: #ffb86c; box-shadow: 0 0 8px #ffb86c; }
    .ghost-purple {
      background: #bd93f9 !important;
      box-shadow: 0 0 8px #bd93f9;
    }
    .ghost-green {
      background: #50fa7b !important;
      box-shadow: 0 0 8px #50fa7b;
    }

    .timer {
      font-size: 1.2em;
      margin: 15px 0;
      padding: 10px 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 15px;
    }

    .instructions {
      margin-top: 20px;
      text-align: center;
      max-width: 600px;
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .winner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .winner-modal {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      animation: modalAppear 0.5s ease-out;
    }

    @keyframes modalAppear {
      from { transform: scale(0.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .winner-text {
      font-size: 3em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }

    .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
    }

    .size-controls label {
      font-weight: bold;
    }

    .size-controls select {
      padding: 8px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.2);
      color: white;
      font-size: 14px;
    }

    .pickaxe-cell {
      background: gold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #bfa100;
      z-index: 2;
    }

    .life-cell {
      background: #ffb6b6;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #e74c3c;
      z-index: 2;
    }

    .tournament-table {
      margin-top: 20px;
      width: 100%;
      max-width: 500px;
    }

    @media (max-width: 768px) {
      .game-container {
        flex-direction: column;
        align-items: center;
      }

      .cell {
        width: 10px;
        height: 10px;
      }

      .header h1 {
        font-size: 2em;
      }
    }
  </style>
</head>
<body>
<div class="header">
  <h1>üèÅ –ì–æ–Ω–∫–∞ –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç–µ</h1>
</div>



<div class="controls">
  <div class="size-controls">
    <label>–†–∞–∑–º–µ—Ä:</label>
    <select id="mazeSize">
      <option value="29" selected>–ë–æ–ª—å—à–æ–π (29x29)</option>
      <option value="35">–û–≥—Ä–æ–º–Ω—ã–π (35x35)</option>
      <option value="45">–ì–∏–≥–∞–Ω—Ç—Å–∫–∏–π (45x45)</option>
    </select>
  </div>
  <button class="btn" id="newGameBtn">üéÆ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  <button class="btn" id="pauseBtn" disabled>‚è∏Ô∏è –ü–∞—É–∑–∞</button>
  <button class="btn" id="helpBtn">‚ùì –ü–æ–º–æ—â—å</button>
</div>

<div class="timer" id="timer">–í—Ä–µ–º—è: 00:00</div>

<div class="game-container">
  <div class="player-section">
    <div class="player-info">
      <div class="player-name">üéÆ –ò–ì–†–û–ö</div>
      <div class="player-status status-ready" id="playerStatus">–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ</div>
    </div>
    <div class="maze-container">
      <div class="maze" id="playerMaze"></div>
    </div>
  </div>

  <div class="player-section">
    <div class="player-info">
      <div class="player-name">ü§ñ –ö–û–ú–ü–¨–Æ–¢–ï–†</div>
      <div class="player-status status-ready" id="computerStatus">–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ</div>
    </div>
    <div class="maze-container">
      <div class="maze" id="computerMaze"></div>
    </div>
  </div>
</div>


<div class="winner-overlay" id="winnerOverlay">
  <div class="winner-modal">
    <div class="winner-text" id="winnerText">üèÜ –ü–û–ë–ï–î–ê!</div>
    <p id="winnerMessage">–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø–æ–±–µ–¥–æ–π!</p>
    <button class="btn" id="playAgainBtn">üîÑ –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
  </div>
</div>

<script>
  class MazeGenerator {
    constructor(size) {
      this.size = size;
      this.maze = [];
      this.generate();
    }

    generate() {
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–∞–±–∏—Ä–∏–Ω—Ç–∞ —Å—Ç–µ–Ω–∞–º–∏
      this.maze = Array(this.size).fill().map(() => Array(this.size).fill(1));

      // –ê–ª–≥–æ—Ä–∏—Ç–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞ (Recursive Backtracking)
      const stack = [];
      const start = [1, 1];
      this.maze[start[0]][start[1]] = 0;
      stack.push(start);

      while (stack.length > 0) {
        const current = stack[stack.length - 1];
        const neighbors = this.getUnvisitedNeighbors(current);

        if (neighbors.length > 0) {
          const next = neighbors[Math.floor(Math.random() * neighbors.length)];
          this.removeWall(current, next);
          this.maze[next[0]][next[1]] = 0;
          stack.push(next);
        } else {
          stack.pop();
        }
      }

      // –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º –≤—ã—Ö–æ–¥
      this.maze[this.size - 2][this.size - 2] = 0;
    }

    getUnvisitedNeighbors([row, col]) {
      const neighbors = [];
      const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];

      for (const [dr, dc] of directions) {
        const newRow = row + dr;
        const newCol = col + dc;

        if (newRow > 0 && newRow < this.size - 1 &&
          newCol > 0 && newCol < this.size - 1 &&
          this.maze[newRow][newCol] === 1) {
          neighbors.push([newRow, newCol]);
        }
      }

      return neighbors;
    }

    removeWall([row1, col1], [row2, col2]) {
      const wallRow = (row1 + row2) / 2;
      const wallCol = (col1 + col2) / 2;
      this.maze[wallRow][wallCol] = 0;
    }
  }

  class MazeGame {
    constructor() {
      this.size = 21;
      this.playerMaze = null;
      this.computerMaze = null;
      this.playerPos = [1, 1];
      this.computerPos = [1, 1];
      this.isGameActive = false;
      this.isPaused = false;
      this.startTime = null;
      this.timerInterval = null;
      this.computerInterval = null;
      this.computerPath = [];
      this.computerPathIndex = 0;
      this.playerDirection = null;
      this.playerMoveInterval = null;
      this.ghosts = [];
      this.ghostMoveInterval = null;
      this.computerGhosts = [];
      this.computerGhostMoveInterval = null;
      this.computerLogic = 'smart'; // –í—Å–µ–≥–¥–∞ —É–º–Ω—ã–π
      this.eventInterval = null;
      // –ù–æ–≤—ã–µ —Ñ–ª–∞–≥–∏
      this.playerCaughtFlag = false;
      this.computerCaughtFlag = false;
      this.pickaxePos = null;
      this.pickaxeVisible = false;
      this.pickaxeTimeout = null;
      this.pickaxeRespawnTimeout = null;
      this.playerHasPickaxe = false;
      this.computerHasPickaxe = false;
      this.lifePos = null;
      this.lifeVisible = false;
      this.lifeTimeout = null;
      this.lifeRespawnTimeout = null;
      this.playerLives = 0;
      this.computerLives = 0;
      this.playerScore = 0;
      this.computerScore = 0;
      this.playerWins = 0;
      this.computerWins = 0;
      this.playerGames = 0;
      this.computerGames = 0;
      this.maxGames = 38;
      this.ghostColorChangeInterval = null;
      this.loadTournamentData();
      this.updateTournamentTable();
      this.initializeElements();
      this.setupEventListeners();
    }

    initializeElements() {
      this.playerMazeEl = document.getElementById('playerMaze');
      this.computerMazeEl = document.getElementById('computerMaze');
      this.playerStatusEl = document.getElementById('playerStatus');
      this.computerStatusEl = document.getElementById('computerStatus');
      this.timerEl = document.getElementById('timer');
      this.winnerOverlay = document.getElementById('winnerOverlay');
      this.winnerText = document.getElementById('winnerText');
      this.winnerMessage = document.getElementById('winnerMessage');
      this.newGameBtn = document.getElementById('newGameBtn');
      this.pauseBtn = document.getElementById('pauseBtn');
      this.playAgainBtn = document.getElementById('playAgainBtn');
      this.mazeSizeSelect = document.getElementById('mazeSize');
    }

    setupEventListeners() {
      this.newGameBtn.addEventListener('click', () => this.newGame());
      this.pauseBtn.addEventListener('click', () => this.togglePause());
      this.playAgainBtn.addEventListener('click', () => this.newGame());

      document.getElementById('helpBtn').addEventListener('click', () => {
        alert('üéØ –¶–µ–ª—å: –î–æ–±–µ—Ä–∏—Ç–µ—Å—å –¥–æ –∫—Ä–∞—Å–Ω–æ–≥–æ –∫–≤–∞–¥—Ä–∞—Ç–∞ –±—ã—Å—Ç—Ä–µ–µ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞!\n\nüéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:\n‚Ä¢ –°—Ç—Ä–µ–ª–∫–∏ ‚Üê‚Üë‚Üì‚Üí\n‚Ä¢ –ò–ª–∏ –∫–ª–∞–≤–∏—à–∏ WASD\n\nüìã –ü—Ä–∞–≤–∏–ª–∞:\n‚Ä¢ –ó–µ–ª–µ–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç - —Å—Ç–∞—Ä—Ç\n‚Ä¢ –ö—Ä–∞—Å–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç - —Ñ–∏–Ω–∏—à\n‚Ä¢ –ù–µ–ª—å–∑—è –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ —Ç–µ–º–Ω—ã–µ —Å—Ç–µ–Ω—ã');
      });

      document.addEventListener('keydown', (e) => this.handleKeyPress(e));

      this.mazeSizeSelect.addEventListener('change', (e) => {
        this.size = parseInt(e.target.value);
      });
    }

    clearAllIntervals() {
      if (this.timerInterval) clearInterval(this.timerInterval);
      if (this.computerInterval) clearInterval(this.computerInterval);
      if (this.playerMoveInterval) clearInterval(this.playerMoveInterval);
      if (this.ghostMoveInterval) clearInterval(this.ghostMoveInterval);
      if (this.computerGhostMoveInterval) clearInterval(this.computerGhostMoveInterval);
      if (this.eventInterval) clearInterval(this.eventInterval);
      if (this.ghostColorChangeInterval) clearInterval(this.ghostColorChangeInterval);
    }

    newGame() {
      this.clearAllIntervals();
      this.isGameActive = true;
      this.isPaused = false;
      this.startTime = Date.now();
      this.playerPos = [1, 1];
      this.computerPos = [1, 1];
      this.playerDirection = null;
      this.computerLogic = 'smart'; // –í—Å–µ–≥–¥–∞ —É–º–Ω—ã–π
      // –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤
      this.playerCaughtFlag = false;
      this.computerCaughtFlag = false;
      this.pickaxePos = null;
      this.pickaxeVisible = false;
      this.playerHasPickaxe = false;
      this.computerHasPickaxe = false;
      this.lifePos = null;
      this.lifeVisible = false;
      this.playerLives = 0;
      this.computerLives = 0;
      if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
      if (this.pickaxeRespawnTimeout) clearTimeout(this.pickaxeRespawnTimeout);
      if (this.lifeTimeout) clearTimeout(this.lifeTimeout);
      if (this.lifeRespawnTimeout) clearTimeout(this.lifeRespawnTimeout);
      this.spawnPickaxeWithDelay();
      this.spawnLifeWithDelay();

      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–µ –ª–∞–±–∏—Ä–∏–Ω—Ç—ã –¥–ª—è –∏–≥—Ä–æ–∫–∞ –∏ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
      const playerGenerator = new MazeGenerator(this.size);
      const computerGenerator = new MazeGenerator(this.size);
      this.playerMaze = playerGenerator.maze.map(row => [...row]);
      this.computerMaze = computerGenerator.maze.map(row => [...row]);

      const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
      const ghostColors = ['ghost-pink', 'ghost-cyan', 'ghost-orange', 'ghost-purple', 'ghost-green'];
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–∑—Ä–∞–∫–æ–≤ –∏–≥—Ä–æ–∫–∞ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏ (–≤—Å–µ–≥–¥–∞ 2-3 –ø—Ä–∏–∑—Ä–∞–∫–∞)
      this.ghosts = [];
      const playerGhostCount = Math.floor(Math.random() * 2) + 2; // 2-3 –ø—Ä–∏–∑—Ä–∞–∫–∞
      for (let i = 0; i < playerGhostCount; i++) {
        this.ghosts.push({
          pos: this.getRandomEmptyPosition(this.playerMaze),
          state: 'patrolling',
          direction: directions[Math.floor(Math.random() * directions.length)],
          path: [],
          pathIndex: 0,
          colorClass: ghostColors[Math.floor(Math.random() * ghostColors.length)]
        });
      }
      
      // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–∑—Ä–∞–∫–æ–≤ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ü–≤–µ—Ç–∞–º–∏ (–≤—Å–µ–≥–¥–∞ 2-3 –ø—Ä–∏–∑—Ä–∞–∫–∞)
      this.computerGhosts = [];
      const computerGhostCount = Math.floor(Math.random() * 2) + 2; // 2-3 –ø—Ä–∏–∑—Ä–∞–∫–∞
      for (let i = 0; i < computerGhostCount; i++) {
        this.computerGhosts.push({
          pos: this.getRandomEmptyPosition(this.computerMaze),
          state: 'patrolling',
          direction: directions[Math.floor(Math.random() * directions.length)],
          path: [],
          pathIndex: 0,
          colorClass: ghostColors[Math.floor(Math.random() * ghostColors.length)]
        });
      }

      this.renderMazes();
      this.updateStatus('playing');
      this.startTimer();
      this.startComputerAI();
      this.startPlayerAutoMove();
      this.startGhostAI();
      this.startComputerGhostAI();
      this.startRandomMazeEvents();
      this.startGhostColorChange();

      this.newGameBtn.textContent = 'üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞';
      this.pauseBtn.disabled = false;
      this.winnerOverlay.style.display = 'none';
    }

    renderMazes() {
      this.renderMaze(this.playerMazeEl, this.playerMaze, this.playerPos, 'player');
      this.renderMaze(this.computerMazeEl, this.computerMaze, this.computerPos, 'computer');
      // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∂–∏–∑–Ω–µ–π –∏ –ø—Ä–∏–∑—Ä–∞–∫–æ–≤
      let playerLivesEl = document.getElementById('playerLives');
      let computerLivesEl = document.getElementById('computerLives');
      if (!playerLivesEl) {
        playerLivesEl = document.createElement('div');
        playerLivesEl.id = 'playerLives';
        playerLivesEl.style.marginTop = '8px';
        playerLivesEl.style.fontSize = '1.1em';
        this.playerMazeEl.parentElement.appendChild(playerLivesEl);
      }
      if (!computerLivesEl) {
        computerLivesEl = document.createElement('div');
        computerLivesEl.id = 'computerLives';
        computerLivesEl.style.marginTop = '8px';
        computerLivesEl.style.fontSize = '1.1em';
        this.computerMazeEl.parentElement.appendChild(computerLivesEl);
      }
      playerLivesEl.innerHTML = `–ñ–∏–∑–Ω–∏: ${'‚ù§Ô∏è'.repeat(this.playerLives)} | –ü—Ä–∏–∑—Ä–∞–∫–∏: üëª ${this.ghosts.length}`;
      computerLivesEl.innerHTML = `–ñ–∏–∑–Ω–∏: ${'‚ù§Ô∏è'.repeat(this.computerLives)} | –ü—Ä–∏–∑—Ä–∞–∫–∏: üëª ${this.computerGhosts.length}`;
    }

    renderMaze(container, maze, pos, playerType) {
      container.innerHTML = '';
      container.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
      for (let row = 0; row < this.size; row++) {
        for (let col = 0; col < this.size; col++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (maze[row][col] === 1) {
            cell.classList.add('wall');
          } else {
            cell.classList.add('path');
          }
          // –°—Ç–∞—Ä—Ç
          if (row === 1 && col === 1) {
            cell.classList.add('start');
          }
          // –§–∏–Ω–∏—à
          if (row === this.size - 2 && col === this.size - 2) {
            cell.classList.add('end');
          }
          // –ü–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞/–∫–æ–º–ø—å—é—Ç–µ—Ä–∞
          if (row === pos[0] && col === pos[1]) {
            cell.classList.add(playerType);
          }
          // –ü—Ä–∏–∑—Ä–∞–∫–∏
          if (playerType === 'player') {
            for (const ghost of this.ghosts) {
              if (row === ghost.pos[0] && col === ghost.pos[1]) {
                cell.classList.add('ghost', ghost.colorClass);
              }
            }
          }
          if (playerType === 'computer') {
            for (const ghost of this.computerGhosts) {
              if (row === ghost.pos[0] && col === ghost.pos[1]) {
                cell.classList.add('ghost', ghost.colorClass);
              }
            }
          }
          // –ö–∏—Ä–∫–∞
          if (this.pickaxeVisible && this.pickaxePos && row === this.pickaxePos[0] && col === this.pickaxePos[1]) {
            cell.classList.add('pickaxe-cell');
            cell.innerHTML = '<span style="font-size:13px;">ü™ì</span>';
          }
          // –ñ–∏–∑–Ω—å
          if (this.lifeVisible && this.lifePos && row === this.lifePos[0] && col === this.lifePos[1]) {
            cell.classList.add('life-cell');
            cell.innerHTML = '<span style="font-size:13px;">‚ù§Ô∏è</span>';
          }
          container.appendChild(cell);
        }
      }
    }

    handleKeyPress(e) {
      if (!this.isGameActive || this.isPaused) return;

      const keyMap = {
        'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
        'ArrowDown': [1, 0], 'KeyS': [1, 0],
        'ArrowLeft': [0, -1], 'KeyA': [0, -1],
        'ArrowRight': [0, 1], 'KeyD': [0, 1]
      };

      const direction = keyMap[e.code];
      if (direction) {
        e.preventDefault();
        this.playerDirection = direction;
      }

      // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∏—Ä–∫—É (E)
      if (e.code === 'KeyE' && this.playerHasPickaxe) {
        this.tryBreakWall();
      }
    }

    startPlayerAutoMove() {
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –µ—Å–ª–∏ –µ—Å—Ç—å
      if (this.playerMoveInterval) { clearInterval(this.playerMoveInterval); this.playerMoveInterval = null; }
      this.playerMoveInterval = setInterval(() => {
        if (!this.isGameActive || this.isPaused || !this.playerDirection) return;
        const newRow = this.playerPos[0] + this.playerDirection[0];
        const newCol = this.playerPos[1] + this.playerDirection[1];
        if (this.isValidMove(newRow, newCol, this.playerMaze)) {
          this.playerPos = [newRow, newCol];
          this.checkPickaxePickup();
          this.checkLifePickup();
          this.renderMazes();
          this.checkWin('player');
          this.checkCollision();
        }
      }, 80);
    }

    checkPickaxePickup() {
      // –î–ª—è –∏–≥—Ä–æ–∫–∞
      if (this.pickaxeVisible && this.pickaxePos && this.playerPos[0] === this.pickaxePos[0] && this.playerPos[1] === this.pickaxePos[1]) {
        this.playerHasPickaxe = true;
        this.hidePickaxe();
        this.renderMazes();
      }
      // –î–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
      if (this.pickaxeVisible && this.pickaxePos && this.computerPos[0] === this.pickaxePos[0] && this.computerPos[1] === this.pickaxePos[1]) {
        this.computerHasPickaxe = true;
        this.hidePickaxe();
        this.renderMazes();
      }
    }

    checkLifePickup() {
      // –î–ª—è –∏–≥—Ä–æ–∫–∞
      if (this.lifeVisible && this.lifePos && this.playerPos[0] === this.lifePos[0] && this.playerPos[1] === this.lifePos[1]) {
        this.playerLives++;
        this.hideLife();
        this.renderMazes();
      }
      // –î–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
      if (this.lifeVisible && this.lifePos && this.computerPos[0] === this.lifePos[0] && this.computerPos[1] === this.lifePos[1]) {
        this.computerLives++;
        this.hideLife();
        this.renderMazes();
      }
    }

    startComputerAI() {
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –µ—Å–ª–∏ –µ—Å—Ç—å
      if (this.computerInterval) { clearInterval(this.computerInterval); this.computerInterval = null; }
      // –ü—É—Ç—å –±—É–¥–µ—Ç –≤—ã—á–∏—Å–ª—è—Ç—å—Å—è –Ω–∞ –ª–µ—Ç—É
      this.computerPath = [];
      this.computerPathIndex = 0;
      this.computerInterval = setInterval(() => {
        if (!this.isGameActive || this.isPaused) return;
        this.moveComputer();
      }, 100); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
    }

    moveComputer() {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∏–¥–∏—Ç –ª–∏ –∫–æ–º–ø—å—é—Ç–µ—Ä –ø—Ä–∏–∑—Ä–∞–∫–∞
      const ghost = this.getVisibleGhostForComputer();
      if (ghost) {
        // –†–µ–∂–∏–º –±–µ–≥—Å—Ç–≤–∞: –∏—â–µ–º –ø—É—Ç—å, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —É–¥–∞–ª—è—é—â–∏–π –æ—Ç –ø—Ä–∏–∑—Ä–∞–∫–∞
        const escapeTarget = this.getEscapeTarget(this.computerPos, ghost.pos, this.computerMaze);
        if (!this.computerPath || this.computerPath.length === 0 || this.computerPathIndex >= this.computerPath.length || Math.random() < 0.2) {
          this.computerPath = this.findPathAStar(this.computerMaze, this.computerPos, escapeTarget);
          this.computerPathIndex = 1;
        }
        if (this.computerPath && this.computerPathIndex < this.computerPath.length) {
          this.computerPos = this.computerPath[this.computerPathIndex];
          this.computerPathIndex++;
        }
      } else {
        // –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º A*
        if (!this.computerPath || this.computerPath.length === 0 || this.computerPathIndex >= this.computerPath.length) {
          this.computerPath = this.findPathAStar(this.computerMaze, this.computerPos, [this.size - 2, this.size - 2]);
          this.computerPathIndex = 1;
          // –ï—Å–ª–∏ –ø—É—Ç—å –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω –∏ –µ—Å—Ç—å –∫–∏—Ä–∫–∞ ‚Äî —Ä–∞–∑–±–∏—Ç—å —Å—Ç–µ–Ω—É
          if (this.computerPath.length <= 1 && this.computerHasPickaxe) {
            this.computerBreakWallToExit();
            // –ü–æ—Å–ª–µ —Ä–∞–∑–±–∏—Ç–∏—è —Å—Ç–µ–Ω—ã ‚Äî –ø–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å –ø—É—Ç—å
            this.computerPath = this.findPathAStar(this.computerMaze, this.computerPos, [this.size - 2, this.size - 2]);
            this.computerPathIndex = 1;
          }
        }
        if (this.computerPath && this.computerPathIndex < this.computerPath.length) {
          this.computerPos = this.computerPath[this.computerPathIndex];
          this.computerPathIndex++;
        }
      }
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä –∫–∏—Ä–∫–∏
      this.checkPickaxePickup();
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–¥–±–æ—Ä –∂–∏–∑–Ω–∏
      this.checkLifePickup();
      this.renderMazes();
      this.checkWin('computer');
    }

    getVisibleGhostForComputer() {
      const [cRow, cCol] = this.computerPos;
      const vision = 10;
      for (const ghost of this.ghosts) {
        const [gRow, gCol] = ghost.pos;
        // –ü–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
        if (cRow === gRow && Math.abs(cCol - gCol) <= vision) {
          const start = Math.min(cCol, gCol);
          const end = Math.max(cCol, gCol);
          let wall = false;
          for (let i = start + 1; i < end; i++) {
            if (this.computerMaze[cRow][i] === 1) { wall = true; break; }
          }
          if (!wall) return ghost;
        }
        // –ü–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
        if (cCol === gCol && Math.abs(cRow - gRow) <= vision) {
          const start = Math.min(cRow, gRow);
          const end = Math.max(cRow, gRow);
          let wall = false;
          for (let i = start + 1; i < end; i++) {
            if (this.computerMaze[i][cCol] === 1) { wall = true; break; }
          }
          if (!wall) return ghost;
        }
      }
      return null;
    }

    getEscapeTarget(from, threat, maze) {
      // –ù–∞—Ö–æ–¥–∏–º –∫–ª–µ—Ç–∫—É, –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ —É–¥–∞–ª—ë–Ω–Ω—É—é –æ—Ç –ø—Ä–∏–∑—Ä–∞–∫–∞, –Ω–æ –¥–æ—Å—Ç–∏–∂–∏–º—É—é
      let maxDist = -1;
      let best = from;
      for (let row = 1; row < this.size - 1; row++) {
        for (let col = 1; col < this.size - 1; col++) {
          if (maze[row][col] === 0) {
            const dist = Math.abs(row - threat[0]) + Math.abs(col - threat[1]);
            if (dist > maxDist) {
              maxDist = dist;
              best = [row, col];
            }
          }
        }
      }
      return best;
    }

    // –ê–ª–≥–æ—Ä–∏—Ç–º A* –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫—Ä–∞—Ç—á–∞–π—à–µ–≥–æ –ø—É—Ç–∏
    findPathAStar(maze, start, goal) {
      // –ü—Ä–∏–∑—Ä–∞–∫–∏ –Ω–µ –º–æ–≥—É—Ç —Å—Ç—Ä–æ–∏—Ç—å –ø—É—Ç—å –∫ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
      if (goal[0] === 1 && goal[1] === 1) return [start];
      const size = this.size;
      const openSet = [start];
      const cameFrom = {};
      const gScore = Array(size).fill().map(() => Array(size).fill(Infinity));
      const fScore = Array(size).fill().map(() => Array(size).fill(Infinity));
      gScore[start[0]][start[1]] = 0;
      fScore[start[0]][start[1]] = this.heuristic(start, goal);

      function posToStr(pos) { return pos[0] + ',' + pos[1]; }
      function strToPos(str) { return str.split(',').map(Number); }

      while (openSet.length > 0) {
        // –ù–∞—Ö–æ–¥–∏–º —É–∑–µ–ª —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º fScore
        let currentIdx = 0;
        for (let i = 1; i < openSet.length; i++) {
          const [r, c] = openSet[i];
          if (fScore[r][c] < fScore[openSet[currentIdx][0]][openSet[currentIdx][1]]) {
            currentIdx = i;
          }
        }
        const current = openSet.splice(currentIdx, 1)[0];
        if (current[0] === goal[0] && current[1] === goal[1]) {
          // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—É—Ç—å
          let path = [goal];
          let currStr = posToStr(goal);
          while (cameFrom[currStr]) {
            currStr = cameFrom[currStr];
            path.push(strToPos(currStr));
          }
          path.reverse();
          return path;
        }
        const directions = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr, dc] of directions) {
          const nr = current[0] + dr, nc = current[1] + dc;
          if (nr >= 0 && nr < size && nc >= 0 && nc < size && maze[nr][nc] === 0) {
            const tentative_gScore = gScore[current[0]][current[1]] + 1;
            if (tentative_gScore < gScore[nr][nc]) {
              cameFrom[posToStr([nr, nc])] = posToStr(current);
              gScore[nr][nc] = tentative_gScore;
              fScore[nr][nc] = tentative_gScore + this.heuristic([nr, nc], goal);
              if (!openSet.some(([r, c]) => r === nr && c === nc)) {
                openSet.push([nr, nc]);
              }
            }
          }
        }
      }
      // –ù–µ—Ç –ø—É—Ç–∏
      return [start];
    }

    heuristic(pos, goal) {
      // –ú–∞–Ω—Ö—ç—Ç—Ç–µ–Ω—Å–∫–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
      return Math.abs(pos[0] - goal[0]) + Math.abs(pos[1] - goal[1]);
    }

    checkWin(player) {
      const pos = player === 'player' ? this.playerPos : this.computerPos;
      const target = [this.size - 2, this.size - 2];
      // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –∏–ª–∏ –∫–æ–º–ø—å—é—Ç–µ—Ä —É–∂–µ –ø–æ–π–º–∞–Ω, –Ω–µ –¥–∞—ë–º –ø–æ–±–µ–¥–∏—Ç—å
      if ((player === 'player' && this.playerCaughtFlag) || (player === 'computer' && this.computerCaughtFlag)) return;
      if (pos[0] === target[0] && pos[1] === target[1]) {
        this.endGame(player);
      }
    }

    endGame(winner) {
      this.isGameActive = false;
      this.clearAllIntervals();
      let isDraw = false;
      // –ï—Å–ª–∏ –Ω–∏—á—å—è
      if (this.playerCaughtFlag && this.computerCaughtFlag) {
        isDraw = true;
      }
      // –ï—Å–ª–∏ –Ω–∏—á—å—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏
      if (
        this.playerStatusEl.textContent === '–ù–ò–ß–¨–Ø!' &&
        this.computerStatusEl.textContent === '–ù–ò–ß–¨–Ø!'
      ) {
        isDraw = true;
      }
      if (isDraw) {
        this.playerScore += 1;
        this.computerScore += 1;
        this.playerGames += 1;
        this.computerGames += 1;
        this.saveTournamentData();
        this.updateTournamentTable();
        this.updateStatus('finished');
        this.playerStatusEl.textContent = '–ù–ò–ß–¨–Ø!';
        this.playerStatusEl.className = 'player-status status-finished';
        this.computerStatusEl.textContent = '–ù–ò–ß–¨–Ø!';
        this.computerStatusEl.className = 'player-status status-finished';
        setTimeout(() => {
          this.winnerText.textContent = 'ü§ù –ù–ò–ß–¨–Ø!';
          this.winnerMessage.textContent = '–û–±–æ–∏—Ö –ø–æ–π–º–∞–ª–∏ –ø—Ä–∏–∑—Ä–∞–∫–∏ –∏–ª–∏ –≤—Ä–µ–º—è –≤—ã—à–ª–æ!';
          this.winnerOverlay.style.display = 'flex';
        }, 500);
        this.pauseBtn.disabled = true;
        this.checkResetTournament();
        return;
      }
      const isPlayerWinner = winner === 'player';
      if (isPlayerWinner) {
        this.playerScore += 3;
        this.playerWins += 1;
        this.playerGames += 1;
        this.computerGames += 1;
      } else {
        this.computerScore += 3;
        this.computerWins += 1;
        this.playerGames += 1;
        this.computerGames += 1;
      }
      this.saveTournamentData();
      this.updateTournamentTable();
      this.updateStatus('finished');
      if (isPlayerWinner) {
        this.playerStatusEl.textContent = '–ü–û–ë–ï–î–ò–¢–ï–õ–¨!';
        this.playerStatusEl.className = 'player-status status-winner';
      } else {
        this.computerStatusEl.textContent = '–ü–û–ë–ï–î–ò–¢–ï–õ–¨!';
        this.computerStatusEl.className = 'player-status status-winner';
      }
      setTimeout(() => {
        this.winnerText.textContent = isPlayerWinner ? 'üèÜ –í–´ –ü–û–ë–ï–î–ò–õ–ò!' : 'ü§ñ –ö–û–ú–ü–¨–Æ–¢–ï–† –ü–û–ë–ï–î–ò–õ!';
        this.winnerMessage.textContent = isPlayerWinner ?
          '–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –æ–∫–∞–∑–∞–ª–∏—Å—å –±—ã—Å—Ç—Ä–µ–µ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞!' :
          '–ù–µ —Ä–∞—Å—Å—Ç—Ä–∞–∏–≤–∞–π—Ç–µ—Å—å! –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑!';
        this.winnerOverlay.style.display = 'flex';
      }, 500);
      this.pauseBtn.disabled = true;
      this.checkResetTournament();
    }

    updateStatus(status) {
      const statusMap = {
        'ready': { text: '–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ', class: 'status-ready' },
        'playing': { text: '–í –∏–≥—Ä–µ...', class: 'status-playing' },
        'finished': { text: '–§–∏–Ω–∏—à!', class: 'status-finished' }
      };

      const statusInfo = statusMap[status];
      if (status !== 'finished') {
        this.playerStatusEl.textContent = statusInfo.text;
        this.playerStatusEl.className = `player-status ${statusInfo.class}`;
        this.computerStatusEl.textContent = statusInfo.text;
        this.computerStatusEl.className = `player-status ${statusInfo.class}`;
      }
    }

    startTimer() {
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –µ—Å–ª–∏ –µ—Å—Ç—å
      if (this.timerInterval) { clearInterval(this.timerInterval); this.timerInterval = null; }
      this.timerInterval = setInterval(() => {
        if (!this.isPaused && this.isGameActive) {
          const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          this.timerEl.textContent = `–í—Ä–µ–º—è: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          // –ó–∞–≤–µ—Ä—à–∏—Ç—å –∏–≥—Ä—É, –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ 2 –º–∏–Ω—É—Ç—ã
          if (elapsed >= 120) {
            this.isGameActive = false;
            this.clearAllIntervals();
            this.playerStatusEl.textContent = '–ù–ò–ß–¨–Ø!';
            this.playerStatusEl.className = 'player-status status-finished';
            this.computerStatusEl.textContent = '–ù–ò–ß–¨–Ø!';
            this.computerStatusEl.className = 'player-status status-finished';
            setTimeout(() => {
              this.winnerText.textContent = 'ü§ù –ù–ò–ß–¨–Ø!';
              this.winnerMessage.textContent = '–í—Ä–µ–º—è –≤—ã—à–ª–æ! –ù–∏–∫—Ç–æ –Ω–µ —É—Å–ø–µ–ª –≤—ã–±—Ä–∞—Ç—å—Å—è –∏–∑ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞.';
              this.winnerOverlay.style.display = 'flex';
            }, 500);
            this.pauseBtn.disabled = true;
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–∏—á—å–µ–π
            this.playerScore += 1;
            this.computerScore += 1;
            this.playerGames += 1;
            this.computerGames += 1;
            this.saveTournamentData();
            this.updateTournamentTable();
            this.checkResetTournament();
          }
        }
      }, 1000);
    }

    togglePause() {
      this.isPaused = !this.isPaused;
      this.pauseBtn.textContent = this.isPaused ? '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '‚è∏Ô∏è –ü–∞—É–∑–∞';

      if (this.isPaused) {
        this.updateStatus('ready');
      } else {
        this.updateStatus('playing');
        this.startTime += Date.now() - this.pauseTime;
      }

      if (this.isPaused) {
        this.pauseTime = Date.now();
      }
    }

    isValidMove(row, col, maze) {
      return row >= 0 && row < this.size &&
        col >= 0 && col < this.size &&
        maze[row][col] === 0;
    }

    startGhostAI() {
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –µ—Å–ª–∏ –µ—Å—Ç—å
      if (this.ghostMoveInterval) { clearInterval(this.ghostMoveInterval); this.ghostMoveInterval = null; }
      // –î–∞–µ–º –∏–≥—Ä–æ–∫—É 2 —Å–µ–∫—É–Ω–¥—ã —Ñ–æ—Ä—ã
      setTimeout(() => {
        if (!this.isGameActive) return;
        if (this.ghostMoveInterval) { clearInterval(this.ghostMoveInterval); this.ghostMoveInterval = null; }
        this.ghostMoveInterval = setInterval(() => {
          if (!this.isGameActive || this.isPaused) return;
          this.moveGhosts();
        }, 120); // –ü—Ä–∏–∑—Ä–∞–∫–∏ —á—É—Ç—å –º–µ–¥–ª–µ–Ω–Ω–µ–µ –∏–≥—Ä–æ–∫–∞
      }, 2000);
    }

    startComputerGhostAI() {
      // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª, –µ—Å–ª–∏ –µ—Å—Ç—å
      if (this.computerGhostMoveInterval) { clearInterval(this.computerGhostMoveInterval); this.computerGhostMoveInterval = null; }
      // –î–∞–µ–º –∫–æ–º–ø—å—é—Ç–µ—Ä—É 2 —Å–µ–∫—É–Ω–¥—ã —Ñ–æ—Ä—ã
      setTimeout(() => {
        if (!this.isGameActive) return;
        if (this.computerGhostMoveInterval) { clearInterval(this.computerGhostMoveInterval); this.computerGhostMoveInterval = null; }
        this.computerGhostMoveInterval = setInterval(() => {
          if (!this.isGameActive || this.isPaused) return;
          this.moveComputerGhosts();
        }, 120);
      }, 2000);
    }

    moveGhosts() {
      this.moveGhostsGeneric(this.ghosts, this.playerMaze, this.playerPos, () => this.checkCollision());
    }

    moveComputerGhosts() {
      this.moveGhostsGeneric(this.computerGhosts, this.computerMaze, this.computerPos, () => this.checkComputerCollision());
    }

    moveGhostsGeneric(ghosts, maze, targetPos, collisionCallback) {
      for (const ghost of ghosts) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∏–¥–∏—Ç –ª–∏ –ø—Ä–∏–∑—Ä–∞–∫ —Ü–µ–ª—å
        if (this.canSeeTarget(ghost, maze, targetPos)) {
          ghost.state = 'chasing';
        } else {
          ghost.state = 'patrolling';
        }

        if (ghost.state === 'chasing') {
          // –†–µ–∂–∏–º –æ—Ö–æ—Ç—ã: –∏—Å–ø–æ–ª—å–∑—É–µ–º A*
          if (!ghost.path || ghost.pathIndex >= ghost.path.length || Math.random() < 0.1) {
            ghost.path = this.findPathAStar(maze, ghost.pos, targetPos);
            // –ï—Å–ª–∏ –ø—É—Ç—å –≤–µ–¥—ë—Ç –∫ —Å—Ç–∞—Ä—Ç—É ‚Äî –Ω–µ –∏–¥—Ç–∏
            if (ghost.path && ghost.path.length > 0 && ghost.path[ghost.path.length-1][0] === 1 && ghost.path[ghost.path.length-1][1] === 1) {
              ghost.path = [ghost.pos];
            }
            ghost.pathIndex = 1;
          }
          if (ghost.path && ghost.pathIndex < ghost.path.length) {
            // –ù–µ –ø–æ–∑–≤–æ–ª—è–µ–º –ø—Ä–∏–∑—Ä–∞–∫—É –ø–æ–ø–∞—Å—Ç—å –Ω–∞ —Å—Ç–∞—Ä—Ç
            if (ghost.path[ghost.pathIndex][0] === 1 && ghost.path[ghost.pathIndex][1] === 1) {
              // –û—Å—Ç–∞—ë—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–µ
            } else {
              ghost.pos = ghost.path[ghost.pathIndex];
            }
            ghost.pathIndex++;
          }
        } else {
          // –£–ª—É—á—à–µ–Ω–Ω–æ–µ –ø–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ: –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è –Ω–∞–∑–∞–¥, –º–µ–Ω—è—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–∞—Ö
          const possibleDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          const prevDirection = ghost.direction;
          const reverseDirection = prevDirection ? [-prevDirection[0], -prevDirection[1]] : null;
          // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–∫—Ä–æ–º–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ, –µ—Å–ª–∏ –µ—Å—Ç—å –¥—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã)
          let validDirections = possibleDirections.filter(dir => {
            const checkPos = [ghost.pos[0] + dir[0], ghost.pos[1] + dir[1]];
            if ((checkPos[0] === 1 && checkPos[1] === 1)) return false; // –ù–µ –∏–¥—Ç–∏ –Ω–∞ —Å—Ç–∞—Ä—Ç
            if (reverseDirection && dir[0] === reverseDirection[0] && dir[1] === reverseDirection[1]) return false;
            return this.isValidMove(checkPos[0], checkPos[1], maze);
          });
          // –ï—Å–ª–∏ —Ç–æ–ª—å–∫–æ –æ–±—Ä–∞—Ç–Ω—ã–π –ø—É—Ç—å –≤–æ–∑–º–æ–∂–µ–Ω (—Ç—É–ø–∏–∫), —Ä–∞–∑—Ä–µ—à–∞–µ–º –µ–≥–æ
          if (validDirections.length === 0 && reverseDirection) {
            const backPos = [ghost.pos[0] + reverseDirection[0], ghost.pos[1] + reverseDirection[1]];
            if (this.isValidMove(backPos[0], backPos[1], maze) && !(backPos[0] === 1 && backPos[1] === 1)) {
              validDirections = [reverseDirection];
            }
          }
          // –ù–∞ –ø–µ—Ä–µ–∫—Ä–µ—Å—Ç–∫–∞—Ö (–±–æ–ª–µ–µ 1 –≤–∞—Ä–∏–∞–Ω—Ç–∞) –∏–Ω–æ–≥–¥–∞ –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–ª—É—á–∞–π–Ω–æ
          if (validDirections.length > 1 && Math.random() < 0.3) {
            ghost.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
          } else if (validDirections.length > 0) {
            // –ï—Å–ª–∏ —Ç–µ–∫—É—â–µ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –µ—â–µ –≤–∞–ª–∏–¥–Ω–æ, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º, –∏–Ω–∞—á–µ –±–µ—Ä–µ–º –Ω–æ–≤—ã–π
            const nextPos = [ghost.pos[0] + (ghost.direction ? ghost.direction[0] : 0), ghost.pos[1] + (ghost.direction ? ghost.direction[1] : 0)];
            if (!ghost.direction || !this.isValidMove(nextPos[0], nextPos[1], maze) || (nextPos[0] === 1 && nextPos[1] === 1)) {
              ghost.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
            }
          }
          // –î–≤–∏–≥–∞–µ–º—Å—è –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
          if (ghost.direction) {
            const nextPos = [ghost.pos[0] + ghost.direction[0], ghost.pos[1] + ghost.direction[1]];
            if (!(nextPos[0] === 1 && nextPos[1] === 1)) {
              ghost.pos = nextPos;
            }
          }
        }
      }
      collisionCallback();
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏–∑—Ä–∞–∫–æ–≤
      if (ghosts === this.ghosts) {
        this.checkGhostInteractions(this.ghosts, this.playerMaze);
      } else if (ghosts === this.computerGhosts) {
        this.checkGhostInteractions(this.computerGhosts, this.computerMaze);
      }
      this.renderMazes();
    }

    canSeeTarget(ghost, maze, targetPos) {
      // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–µ–≤–∏–¥–∏–º–∞ –¥–ª—è –ø—Ä–∏–∑—Ä–∞–∫–æ–≤
      if (targetPos[0] === 1 && targetPos[1] === 1) return false;
      const [gRow, gCol] = ghost.pos;
      const [tRow, tCol] = targetPos;
      const lineOfSightDistance = 15;
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
      if (gRow === tRow && Math.abs(gCol - tCol) < lineOfSightDistance) {
        const start = Math.min(gCol, tCol);
        const end = Math.max(gCol, tCol);
        let wallFound = false;
        for (let i = start + 1; i < end; i++) {
          if (maze[gRow][i] === 1) { wallFound = true; break; }
        }
        if (!wallFound) return true;
      }
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
      if (gCol === tCol && Math.abs(gRow - tRow) < lineOfSightDistance) {
        const start = Math.min(gRow, tRow);
        const end = Math.max(gRow, tRow);
        let wallFound = false;
        for (let i = start + 1; i < end; i++) {
          if (maze[i][gCol] === 1) { wallFound = true; break; }
        }
        if (!wallFound) return true;
      }
      return false;
    }

    checkCollision() {
      for (const ghost of this.ghosts) {
        if (ghost.pos[0] === this.playerPos[0] && ghost.pos[1] === this.playerPos[1]) {
          if (this.playerLives > 0) {
            this.playerLives--;
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, –º–∏–≥–∞–Ω–∏–µ)
            this.playerPos = [1, 1]; // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞ —Å—Ç–∞—Ä—Ç
            this.renderMazes();
          } else {
            this.playerCaught();
            return;
          }
        }
      }
    }

    checkComputerCollision() {
      for (const ghost of this.computerGhosts) {
        if (ghost.pos[0] === this.computerPos[0] && ghost.pos[1] === this.computerPos[1]) {
          if (this.computerLives > 0) {
            this.computerLives--;
            this.computerPos = [1, 1];
            this.renderMazes();
          } else {
            this.computerCaught();
            return;
          }
        }
      }
    }

    playerCaught() {
      this.playerCaughtFlag = true;
      this.playerStatusEl.textContent = '–ü–û–ô–ú–ê–ù!';
      this.playerStatusEl.className = 'player-status status-finished';
      // –ë–ª–æ–∫–∏—Ä—É–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–º
      this.playerDirection = null;
      // –ï—Å–ª–∏ –∫–æ–º–ø—å—é—Ç–µ—Ä —Ç–æ–∂–µ –ø–æ–π–º–∞–Ω ‚Äî –Ω–∏—á—å—è
      if (this.computerCaughtFlag) {
        this.endGame();
        return;
      }
      // –ï—Å–ª–∏ –∫–æ–º–ø—å—é—Ç–µ—Ä –µ—â—ë –∏–≥—Ä–∞–µ—Ç ‚Äî –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–∞–ª–∫—É, –Ω–µ –∑–∞–≤–µ—Ä—à–∞–µ–º –∏–≥—Ä—É
      // –ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –ø–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–∞–ª–∫—É —Å—Ä–∞–∑—É ‚Äî —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ:
      // setTimeout(() => {
      //   this.winnerText.textContent = 'üëª –í–ê–° –ü–û–ô–ú–ê–õ–ò!';
      //   this.winnerMessage.textContent = '–ü—Ä–∏–∑—Ä–∞–∫–∏ –æ–∫–∞–∑–∞–ª–∏—Å—å –ø—Ä–æ–≤–æ—Ä–Ω–µ–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞!';
      //   this.winnerOverlay.style.display = 'flex';
      // }, 500);
    }

    computerCaught() {
      this.computerCaughtFlag = true;
      this.computerStatusEl.textContent = '–ü–û–ô–ú–ê–ù!';
      this.computerStatusEl.className = 'player-status status-finished';
      this.computerPos = [-1, -1];
      this.renderMazes();
      // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ —Ç–æ–∂–µ –ø–æ–π–º–∞–Ω ‚Äî –Ω–∏—á—å—è
      if (this.playerCaughtFlag) {
        this.endGame();
        return;
      }
      // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –µ—â—ë –∏–≥—Ä–∞–µ—Ç ‚Äî –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–∞–ª–∫—É, –Ω–µ –∑–∞–≤–µ—Ä—à–∞–µ–º –∏–≥—Ä—É
      // –ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –ø–æ–∫–∞–∑–∞—Ç—å –º–æ–¥–∞–ª–∫—É —Å—Ä–∞–∑—É ‚Äî —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ:
      // setTimeout(() => {
      //   this.winnerText.textContent = 'üëª –ö–û–ú–ü–¨–Æ–¢–ï–† –ü–û–ô–ú–ê–ù!';
      //   this.winnerMessage.textContent = '–ö–æ–º–ø—å—é—Ç–µ—Ä –ø—Ä–æ–∏–≥—Ä–∞–ª –ø—Ä–∏–∑—Ä–∞–∫–∞–º!';
      //   this.winnerOverlay.style.display = 'flex';
      // }, 500);
    }

    getRandomEmptyPosition(maze) {
      let row, col;
      do {
        row = Math.floor(Math.random() * (this.size - 2)) + 1;
        col = Math.floor(Math.random() * (this.size - 2)) + 1;
      } while (
        maze[row][col] === 1 || // –ù–µ —Å—Ç–µ–Ω–∞
        (row === 1 && col === 1) || // –ù–µ —Å—Ç–∞—Ä—Ç –∏–≥—Ä–æ–∫–∞
        (row === this.size - 2 && col === this.size - 2) // –ù–µ —Ñ–∏–Ω–∏—à
      );
      return [row, col];
    }

    startRandomMazeEvents() {
      this.eventInterval = setInterval(() => {
        if (!this.isGameActive || this.isPaused) return;
        this.randomMazeEvent(this.playerMaze, [this.playerPos, ...this.ghosts.map(g => g.pos)]);
        this.randomMazeEvent(this.computerMaze, [this.computerPos, ...this.computerGhosts.map(g => g.pos)]);
        this.renderMazes();
      }, 10000);
    }

    randomMazeEvent(maze, forbiddenPositions) {
      // 50/50: –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å —Å—Ç–µ–Ω—É
      const isAdd = Math.random() < 0.5;
      const size = this.size;
      const forbiddenSet = new Set(forbiddenPositions.map(pos => pos[0] + ',' + pos[1]));
      forbiddenSet.add('1,1');
      forbiddenSet.add((size-2) + ',' + (size-2));
      // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –¥–æ 100 —Ä–∞–∑ –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â—É—é –∫–ª–µ—Ç–∫—É
      for (let attempt = 0; attempt < 100; attempt++) {
        const row = Math.floor(Math.random() * (size - 2)) + 1;
        const col = Math.floor(Math.random() * (size - 2)) + 1;
        const key = row + ',' + col;
        if (forbiddenSet.has(key)) continue;
        if (isAdd && maze[row][col] === 0) {
          maze[row][col] = 1;
          break;
        }
        if (!isAdd && maze[row][col] === 1) {
          maze[row][col] = 0;
          break;
        }
      }
    }

    spawnPickaxeWithDelay() {
      // –ü–æ—è–≤–∏—Ç—Å—è —á–µ—Ä–µ–∑ 3-7 —Å–µ–∫—É–Ω–¥
      const delay = 3000 + Math.random() * 4000;
      this.pickaxeRespawnTimeout = setTimeout(() => {
        this.spawnPickaxe();
      }, delay);
    }

    spawnPickaxe() {
      if (!this.isGameActive) return;
      // –ù–∞–π—Ç–∏ —Å–ª—É—á–∞–π–Ω—É—é –ø—É—Å—Ç—É—é –∫–ª–µ—Ç–∫—É (–Ω–µ —Å—Ç–µ–Ω–∞, –Ω–µ —Å—Ç–∞—Ä—Ç/—Ñ–∏–Ω–∏—à, –Ω–µ –∏–≥—Ä–æ–∫/–∫–æ–º–ø—å—é—Ç–µ—Ä/–ø—Ä–∏–∑—Ä–∞–∫–∏) –∏ –Ω–∞ –æ–±–µ–∏—Ö –∫–∞—Ä—Ç–∞—Ö
      let row, col;
      let attempts = 0;
      do {
        row = Math.floor(Math.random() * (this.size - 2)) + 1;
        col = Math.floor(Math.random() * (this.size - 2)) + 1;
        attempts++;
      } while (
        (this.playerMaze[row][col] !== 0 || this.computerMaze[row][col] !== 0) ||
        (row === 1 && col === 1) ||
        (row === this.size - 2 && col === this.size - 2) ||
        (row === this.playerPos[0] && col === this.playerPos[1]) ||
        (row === this.computerPos[0] && col === this.computerPos[1]) ||
        this.ghosts.some(g => g.pos[0] === row && g.pos[1] === col) ||
        this.computerGhosts.some(g => g.pos[0] === row && g.pos[1] === col)
        && attempts < 100
      );
      this.pickaxePos = [row, col];
      this.pickaxeVisible = true;
      this.renderMazes();
      // –ò—Å—á–µ–∑–Ω–µ—Ç —á–µ—Ä–µ–∑ 6-10 —Å–µ–∫—É–Ω–¥, –µ—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª–∏
      const duration = 6000 + Math.random() * 4000;
      this.pickaxeTimeout = setTimeout(() => {
        this.hidePickaxe();
        this.spawnPickaxeWithDelay();
      }, duration);
    }

    hidePickaxe() {
      this.pickaxeVisible = false;
      this.pickaxePos = null;
      this.renderMazes();
      if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
    }

    tryBreakWall() {
      // –ú–æ–∂–Ω–æ —Ä–∞–∑–±–∏—Ç—å –æ–¥–Ω—É —Å—Ç–µ–Ω—É –≤–æ–∫—Ä—É–≥ –∏–≥—Ä–æ–∫–∞ (–≤–≤–µ—Ä—Ö, –≤–Ω–∏–∑, –≤–ª–µ–≤–æ, –≤–ø—Ä–∞–≤–æ)
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr,dc] of dirs) {
        const r = this.playerPos[0] + dr;
        const c = this.playerPos[1] + dc;
        if (r >= 0 && r < this.size && c >= 0 && c < this.size && this.playerMaze[r][c] === 1) {
          this.playerMaze[r][c] = 0;
          this.playerHasPickaxe = false;
          this.renderMazes();
          // –ü–æ—Å–ª–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–∏—Ä–∫–∏ ‚Äî –ø–æ—è–≤–∏—Ç—Å—è –Ω–æ–≤–∞—è —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è
          this.spawnPickaxeWithDelay();
          break;
        }
      }
    }

    computerBreakWallToExit() {
      // –ù–∞–π—Ç–∏ —Å—Ç–µ–Ω—É, —É–¥–∞–ª–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä–æ–π —Ä–µ–∞–ª—å–Ω–æ –æ—Ç–∫—Ä–æ–µ—Ç –ø—É—Ç—å –∫ —Ñ–∏–Ω–∏—à—É
      // 1. –î–ª—è –∫–∞–∂–¥–æ–π —Å—Ç–µ–Ω—ã –≤–æ–∫—Ä—É–≥ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞:
      // 2. –í—Ä–µ–º–µ–Ω–Ω–æ —É–±–∏—Ä–∞–µ–º —Å—Ç–µ–Ω—É, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—É—Ç—å A* –∫ —Ñ–∏–Ω–∏—à—É
      // 3. –ï—Å–ª–∏ –ø—É—Ç—å –Ω–∞–π–¥–µ–Ω (–¥–ª–∏–Ω–∞ > 1), —Ä–∞–∑–±–∏–≤–∞–µ–º —ç—Ç—É —Å—Ç–µ–Ω—É
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr,dc] of dirs) {
        const r = this.computerPos[0] + dr;
        const c = this.computerPos[1] + dc;
        if (r >= 0 && r < this.size && c >= 0 && c < this.size && this.computerMaze[r][c] === 1) {
          // –í—Ä–µ–º–µ–Ω–Ω–æ —É–±–∏—Ä–∞–µ–º —Å—Ç–µ–Ω—É
          this.computerMaze[r][c] = 0;
          const path = this.findPathAStar(this.computerMaze, this.computerPos, [this.size - 2, this.size - 2]);
          // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–µ–Ω—É
          this.computerMaze[r][c] = 1;
          if (path.length > 1) {
            // –†–∞–∑–±–∏–≤–∞–µ–º —ç—Ç—É —Å—Ç–µ–Ω—É
            this.computerMaze[r][c] = 0;
            this.computerHasPickaxe = false;
            this.spawnPickaxeWithDelay();
            break;
          }
        }
      }
    }

    spawnLifeWithDelay() {
      // –ü–æ—è–≤–∏—Ç—Å—è —á–µ—Ä–µ–∑ 4-8 —Å–µ–∫—É–Ω–¥
      const delay = 4000 + Math.random() * 4000;
      this.lifeRespawnTimeout = setTimeout(() => {
        this.spawnLife();
      }, delay);
    }

    spawnLife() {
      if (!this.isGameActive) return;
      // –ù–∞–π—Ç–∏ —Å–ª—É—á–∞–π–Ω—É—é –ø—É—Å—Ç—É—é –∫–ª–µ—Ç–∫—É (–Ω–µ —Å—Ç–µ–Ω–∞, –Ω–µ —Å—Ç–∞—Ä—Ç/—Ñ–∏–Ω–∏—à, –Ω–µ –∏–≥—Ä–æ–∫/–∫–æ–º–ø—å—é—Ç–µ—Ä/–ø—Ä–∏–∑—Ä–∞–∫–∏/–∫–∏—Ä–∫–∞) –∏ –Ω–∞ –æ–±–µ–∏—Ö –∫–∞—Ä—Ç–∞—Ö
      let row, col;
      let attempts = 0;
      do {
        row = Math.floor(Math.random() * (this.size - 2)) + 1;
        col = Math.floor(Math.random() * (this.size - 2)) + 1;
        attempts++;
      } while (
        (this.playerMaze[row][col] !== 0 || this.computerMaze[row][col] !== 0) ||
        (row === 1 && col === 1) ||
        (row === this.size - 2 && col === this.size - 2) ||
        (row === this.playerPos[0] && col === this.playerPos[1]) ||
        (row === this.computerPos[0] && col === this.computerPos[1]) ||
        (this.pickaxePos && row === this.pickaxePos[0] && col === this.pickaxePos[1]) ||
        this.ghosts.some(g => g.pos[0] === row && g.pos[1] === col) ||
        this.computerGhosts.some(g => g.pos[0] === row && g.pos[1] === col)
        && attempts < 100
      );
      this.lifePos = [row, col];
      this.lifeVisible = true;
      this.renderMazes();
      // –ò—Å—á–µ–∑–Ω–µ—Ç —á–µ—Ä–µ–∑ 7-12 —Å–µ–∫—É–Ω–¥, –µ—Å–ª–∏ –Ω–µ –ø–æ–¥–æ–±—Ä–∞–ª–∏
      const duration = 7000 + Math.random() * 5000;
      this.lifeTimeout = setTimeout(() => {
        this.hideLife();
        this.spawnLifeWithDelay();
      }, duration);
    }

    hideLife() {
      this.lifeVisible = false;
      this.lifePos = null;
      this.renderMazes();
      if (this.lifeTimeout) clearTimeout(this.lifeTimeout);
    }

    loadTournamentData() {
      const data = JSON.parse(localStorage.getItem('mazeTournamentData') || '{}');
      this.playerScore = data.playerScore || 0;
      this.computerScore = data.computerScore || 0;
      this.playerWins = data.playerWins || 0;
      this.computerWins = data.computerWins || 0;
      this.playerGames = data.playerGames || 0;
      this.computerGames = data.computerGames || 0;
    }

    saveTournamentData() {
      localStorage.setItem('mazeTournamentData', JSON.stringify({
        playerScore: this.playerScore,
        computerScore: this.computerScore,
        playerWins: this.playerWins,
        computerWins: this.computerWins,
        playerGames: this.playerGames,
        computerGames: this.computerGames
      }));
    }

    resetTournamentData() {
      this.playerScore = 0;
      this.computerScore = 0;
      this.playerWins = 0;
      this.computerWins = 0;
      this.playerGames = 0;
      this.computerGames = 0;
      this.saveTournamentData();
      this.updateTournamentTable();
    }

    updateTournamentTable() {
      document.getElementById('playerScore').textContent = this.playerScore;
      document.getElementById('computerScore').textContent = this.computerScore;
      document.getElementById('playerWins').textContent = this.playerWins;
      document.getElementById('computerWins').textContent = this.computerWins;
      document.getElementById('playerGames').textContent = this.playerGames;
      document.getElementById('computerGames').textContent = this.computerGames;
      const totalGames = Math.max(this.playerGames, this.computerGames);
      document.getElementById('gamesCountInfo').textContent = `–°—ã–≥—Ä–∞–Ω–æ –∏–≥—Ä: ${totalGames} / ${this.maxGames}`;
    }

    checkResetTournament() {
      const totalGames = Math.max(this.playerGames, this.computerGames);
      if (totalGames >= this.maxGames) {
        setTimeout(() => {
          alert('–¢—É—Ä–Ω–∏—Ä –∑–∞–≤–µ—Ä—à—ë–Ω! –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—É–¥—É—Ç —Å–±—Ä–æ—à–µ–Ω—ã.');
          this.resetTournamentData();
        }, 1000);
      }
    }

    getRandomColorClass() {
      const ghostColors = ['ghost-pink', 'ghost-cyan', 'ghost-orange', 'ghost-purple', 'ghost-green'];
      return ghostColors[Math.floor(Math.random() * ghostColors.length)];
    }

    startGhostColorChange() {
      if (this.ghostColorChangeInterval) {
        clearInterval(this.ghostColorChangeInterval);
      }
      this.ghostColorChangeInterval = setInterval(() => {
        if (!this.isGameActive || this.isPaused) {
          return;
        }
        // –ò–∑–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø—Ä–∏–∑—Ä–∞–∫–∞ –∏–≥—Ä–æ–∫–∞
        if (this.ghosts.length > 0) {
          const randomGhostIndex = Math.floor(Math.random() * this.ghosts.length);
          const ghostToChange = this.ghosts[randomGhostIndex];
          ghostToChange.colorClass = this.getRandomColorClass();
        }
        // –ò–∑–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø—Ä–∏–∑—Ä–∞–∫–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞
        if (this.computerGhosts.length > 0) {
          const randomGhostIndex = Math.floor(Math.random() * this.computerGhosts.length);
          const ghostToChange = this.computerGhosts[randomGhostIndex];
          ghostToChange.colorClass = this.getRandomColorClass();
        }
        this.renderMazes();
      }, 10000);
    }

    checkGhostInteractions(ghosts, maze) {
      const toRemove = new Set();
      const newGhosts = [];
      const minGhosts = 1;
      const maxGhosts = 4047;

      for (let i = 0; i < ghosts.length; i++) {
        if (toRemove.has(i)) continue;

        for (let j = i + 1; j < ghosts.length; j++) {
          if (toRemove.has(j)) continue;

          const g1 = ghosts[i];
          const g2 = ghosts[j];

          const isTouching = Math.abs(g1.pos[0] - g2.pos[0]) + Math.abs(g1.pos[1] - g2.pos[1]) <= 1;

          // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ü–≤–µ—Ç–∞ –†–ê–ó–ù–´–ï
          if (isTouching && g1.colorClass !== g2.colorClass) {
            
            // 50% —à–∞–Ω—Å –Ω–∞ —Ä–æ–∂–¥–µ–Ω–∏–µ, 50% –Ω–∞ –≥–∏–±–µ–ª—å
            if (Math.random() < 0.5) {
              // --- –†–û–ñ–î–ï–ù–ò–ï ---
              if (ghosts.length + newGhosts.length < maxGhosts) {
                newGhosts.push({
                  pos: this.getRandomEmptyPosition(maze),
                  state: 'patrolling',
                  direction: [0, 1],
                  path: [],
                  pathIndex: 0,
                  colorClass: this.getRandomColorClass() // –ù–æ–≤—ã–π –ø—Ä–∏–∑—Ä–∞–∫ –ø–æ–ª—É—á–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç
                });
              }
            } else {
              // --- –ì–ò–ë–ï–õ–¨ ---
              if (ghosts.length - toRemove.size > minGhosts) {
                // –£–¥–∞–ª—è–µ–º –æ–¥–Ω–æ–≥–æ –∏–∑ –¥–≤—É—Ö —Å—Ç–æ–ª–∫–Ω—É–≤—à–∏—Ö—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º
                toRemove.add(Math.random() < 0.5 ? i : j);
              }
            }
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥–∞–ª—å–Ω–µ–π—à–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è —ç—Ç–æ–π –ø–∞—Ä—ã –≤ —Ç–µ–∫—É—â–µ–º —Ç–∏–∫–µ
            // –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –≥–ª–∞–≤–Ω–æ–º—É –ø—Ä–∏–∑—Ä–∞–∫—É (i)
            break; 
          }
        }
      }

      // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏
      const filteredGhosts = ghosts.filter((_, index) => !toRemove.has(index));
      ghosts.length = 0;
      ghosts.push(...filteredGhosts);
      ghosts.push(...newGhosts);

      // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –ø–æ–ø—É–ª—è—Ü–∏—è –Ω–µ –≤—ã–º—Ä–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é
      while (ghosts.length < minGhosts) {
        ghosts.push({
          pos: this.getRandomEmptyPosition(maze),
          state: 'patrolling',
          direction: [0, 1],
          path: [],
          pathIndex: 0,
          colorClass: this.getRandomColorClass()
        });
      }
    }
  }

  // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
  window.addEventListener('DOMContentLoaded', () => {
    window.mazeGameInstance = new MazeGame();
    // newGame –ù–ï –≤—ã–∑—ã–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!
  });
</script>
<!-- –¢—É—Ä–Ω–∏—Ä–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ -->
<div class="tournament-table">
  <table style="width:100%; background:rgba(255,255,255,0.12); overflow:hidden; border-collapse:collapse;">
    <thead>

    </thead>
    <tbody>
      <tr>
        <td>–ò–≥—Ä–æ–∫</td>
        <td id="playerScore">
        <td id="playerWins">
        <td id="playerGames">
      </tr>
      <tr>
        <td>–ö–æ–º–ø—å—é—Ç–µ—Ä</td>
        <td id="computerScore">
        <td id="computerWins">
        <td id="computerGames">
      </tr>
    </tbody>
  </table>
  <div id="gamesCountInfo"</div>
</div>

<!-- –ú–µ–Ω—é –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º –Ω–∞ —Ç—É—Ä–Ω—ñ—Ä–Ω—É —Ç–∞–±–ª–∏—Ü—é -->
<nav style="margin-bottom: 18px;">
  <a href="index.html" style="color:#fff; font-weight:bold; margin-right:18px; text-decoration:none;">–ì–æ–ª–æ–≤–Ω–∞</a>
  <a href="global.html" style="color:#fff; font-weight:bold; margin-right:18px; text-decoration:none;">GLOBAL</a>
  <a href="standings.html" style="color:#fff; font-weight:bold; text-decoration:none;">–¢—É—Ä–Ω—ñ—Ä–Ω–∞ —Ç–∞–±–ª–∏—Ü—è</a>
</nav>

<div class="instructions">
  <h3>üéØ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏</h3>
  <p><strong>–¶–µ–ª—å:</strong> –î–æ–±–µ—Ä–∏—Ç–µ—Å—å –¥–æ –∫—Ä–∞—Å–Ω–æ–≥–æ –∫–≤–∞–¥—Ä–∞—Ç–∞ (–≤—ã—Ö–æ–¥) –±—ã—Å—Ç—Ä–µ–µ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞!</p>
  <p><strong>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç—Ä–µ–ª–∫–∏ ‚Üê‚Üë‚Üì‚Üí –∏–ª–∏ WASD –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è</p>
  <p><strong>–ü—Ä–∞–≤–∏–ª–∞:</strong> –ó–µ–ª–µ–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç - —Å—Ç–∞—Ä—Ç, –∫—Ä–∞—Å–Ω—ã–π - —Ñ–∏–Ω–∏—à. –ù–µ–ª—å–∑—è –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ —Å—Ç–µ–Ω—ã!</p>
</div>
</body>
</html>