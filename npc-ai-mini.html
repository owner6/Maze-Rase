<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–ó–æ–º–±—ñ-–ê–ø–æ–∫–∞–ª—ñ–ø—Å–∏—Å: –õ–∞–±—ñ—Ä–∏–Ω—Ç –í–∏–∂–∏–≤–∞–Ω–Ω—è</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 50vh;
      padding: 10px;
    }

    .header {
      text-align: center;
      margin-bottom: 0px;
    }

    .header h1 {
      font-size: 1em;
      margin-bottom: 5px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      color: #e74c3c;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 5px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 12px 24px;
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      border: none;
      border-radius: 25px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }

    .btn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(255,255,255,0.05);
      border-radius: 20px;
      padding: 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      max-width: 1400px;
      width: 100%;
    }

    .player-info {
      margin-bottom: 15px;
      text-align: center;
      display: flex;
      gap: 3px;
      align-items: center;
    }

    .player-name {
      font-size: 1em;
      font-weight: bold;
      margin-bottom: 5px;
      color: #3498db;
    }

    .player-status {
      font-size: 1em;
      padding: 5px 10px;
      border-radius: 15px;
      display: inline-block;
    }

    .status-ready { background: rgba(52, 152, 219, 0.8); }
    .status-playing { background: rgba(46, 204, 113, 0.8); }
    .status-finished { background: rgba(231, 76, 60, 0.8); }
    .status-winner { background: rgba(241, 196, 15, 0.8); }

    .maze-container {
      border: 3px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      margin-bottom: 20px;
    }

    .maze {
      display: grid;
      background: #2c3e50;
    }

    .cell {
      width: 24px;
      height: 24px;
      border: 0.5px solid rgba(52, 73, 94, 0.5);
    }

    .wall { background: #34495e; }
    .path { background: #ecf0f1; }
    .start { background: #27ae60; }
    .end { background: #e74c3c; }
    .player { background: #3498db; box-shadow: 0 0 10px #3498db; }
    .zombie { 
      background: #8B4513; 
      box-shadow: 0 0 8px #8B4513;
      border-radius: 50%;
    }
    .zombie-fast { 
      background: #FF4500; 
      box-shadow: 0 0 8px #FF4500;
      border-radius: 50%;
    }
    .zombie-boss { 
      background: #1a0033;
      border-radius: 10px;
      border: 3px solid #ff2222;
      box-shadow: 0 0 16px 4px #ff2222, 0 0 8px 2px #fff;
      position: relative;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .ammo-cell {
      background: #FFD700;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #FFA500;
      z-index: 2;
    }
    .health-cell {
      background: #FF69B4;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #FF1493;
      z-index: 2;
    }
    .shield-cell {
      background: #00CED1;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #008B8B;
      z-index: 2;
    }
    .safe-zone {
      background: #32CD32;
      border: 2px solid #228B22;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }

    .timer {
      font-size: 1.1em;
      margin: 0;
      padding: 5px 15px;
      background: rgba(0,0,0,0.5);
      border-radius: 15px;
      display: inline-block;
    }

    .stats-bar {
      display: flex;
      gap: 20px;
      margin: 5px 5;
      flex-wrap: wrap;
      justify-content: center;
    }

    .stat-item {
      background: rgba(0,0,0,0.3);
      padding: 8px 15px;
      border-radius: 10px;
      font-size: 14px;
    }

    .instructions {
      margin-top: 20px;
      text-align: center;
      max-width: 600px;
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .winner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .winner-modal {
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.7);
      animation: modalAppear 0.5s ease-out;
    }

    @keyframes modalAppear {
      from { transform: scale(0.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .winner-text {
      font-size: 3em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }

    .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
    }

    .size-controls label {
      font-weight: bold;
    }

    .size-controls select {
      padding: 8px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.2);
      color: white;
      font-size: 14px;
    }

    .event-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
      z-index: 1000;
      animation: slideInRight 0.5s ease-out;
      max-width: 300px;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    @media (max-width: 768px) {
      .cell {
        width: 13px;
        height: 13px;
      }

      .header h1 {
        font-size: 2em;
      }
    }

    .pickaxe-cell {
      background: gold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #bfa100;
      z-index: 2;
    }

    .knife-cell {
      background: #8B0000;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #660000;
      z-index: 2;
    }

    .stake-cell {
      background: #FFD700;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #FFA500;
      z-index: 2;
    }

    .mine-cell {
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #444;
      border-radius: 50%;
      position: relative;
      z-index: 2;
    }
    .mine-cell::after {
      content: '';
      width: 6px;
      height: 6px;
      background: #ff2222;
      border-radius: 50%;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    .mine-cell.mine-item {
      background: #ffe066 !important;
      border: 2px solid #ffd700 !important;
    }
    /* Mine placed by zombie */
    .zombie-mine-cell {
      border: 2px solid #8A2BE2 !important; /* Violet border */
    }

    .menu-nav {
      display: flex;
      gap: 14px;
      justify-content: center;
      margin-bottom: 18px;
    }
    .menu-btn {
      display: inline-block;
      padding: 12px 28px;
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      border: none;
      border-radius: 25px;
      color: white;
      font-size: 17px;
      font-weight: bold;
      text-decoration: none;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transition: all 0.2s;
      cursor: pointer;
      outline: none;
    }
    .menu-btn:hover, .menu-btn.active {
      background: linear-gradient(45deg, #c0392b, #e74c3c);
      color: #fffbe6;
      transform: translateY(-2px) scale(1.04);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      text-shadow: 0 1px 4px #0008;
    }

    .mine-detector-cell {
      background: #b0e0e6;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #4682b4;
      z-index: 2;
    }
  </style>
</head>
<body>
<audio id="audioStart" src="sounds/start.wav"></audio>
<audio id="audioKnife" src="sounds/knife.wav"></audio>
<audio id="audioGun" src="sounds/gun.wav"></audio>
<audio id="audioStep" src="sounds/step.wav"></audio>
<audio id="audioZombie" src="sounds/zombie.wav"></audio>
<audio id="audioPickup" src="sounds/pickup.wav"></audio>
<audio id="audioWin" src="sounds/win.wav"></audio>
<audio id="audioLose" src="sounds/lose.mp3"></audio>
<audio id="audioMineExplosion" src="sounds/mine-explosion.flac"></audio>
<audio id="audioMinePlace" src="sounds/mine-place.flac"></audio>
<audio id="audioZombieHit" src="sounds/zombie-hit.wav"></audio>
<audio id="audioZombieKill" src="sounds/zombie-kill.wav"></audio>
<audio id="audioZombieSee" src="sounds/zombie-see.ogg"></audio>
<audio id="audioSafeZone" src="sounds/safe-zone.wav"></audio>
<audio id="audioZombieBite" src="sounds/zombie-bite.wav"></audio>
<audio id="audioBreakWall" src="sounds/break-wall.mp3"></audio>
<audio id="audioPlayerDeath" src="sounds/player-death.mp3"></audio>
<audio id="audioMineDefuse" src="sounds/pickup-of.wav"></audio>

<div class="header">
  <h1>üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ-–ê–ø–æ–∫–∞–ª—ñ–ø—Å–∏—Å: –õ–∞–±—ñ—Ä–∏–Ω—Ç –í–∏–∂–∏–≤–∞–Ω–Ω—è</h1>
</div>

<div class="controls">
  <div class="size-controls">
    <label>–†—ñ–≤–µ–Ω—å —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ:</label>
    <select id="difficultyLevel">
      <option value="easy" selected>–õ–µ–≥–∫–∏–π</option>
      <option value="medium">–°–µ—Ä–µ–¥–Ω—ñ–π</option>
      <option value="hard">–í–∞–∂–∫–∏–π</option>
      <option value="nightmare">–ö–æ—à–º–∞—Ä</option>
    </select>
  </div>
  <button class="btn" id="newGameBtn">üßü‚Äç‚ôÇÔ∏è –ù–æ–≤–∞ –≥—Ä–∞</button>
  <button class="btn" id="pauseBtn" disabled>‚è∏Ô∏è –ü–∞—É–∑–∞</button>
  <button class="btn" id="helpBtn">‚ùì –î–æ–ø–æ–º–æ–≥–∞</button>
</div>

<div class="game-container">
  <div class="player-info">
    <div>
      <div class="player-name">üéØ –ì–†–ê–í–ï–¶–¨</div>
      <div class="player-status status-ready" id="playerStatus">–ì–æ—Ç–æ–≤ –¥–æ –≤–∏–∂–∏–≤–∞–Ω–Ω—è</div>
    </div>
    <div class="timer" id="timer">–ß–∞—Å –≤–∏–∂–∏–≤–∞–Ω–Ω—è: 00:00</div>
  </div>
  
  <div class="stats-bar" id="statsBar">
    <div class="stat-item">‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤'—è: <span id="healthDisplay">100</span></div>
    <div class="stat-item">üõ°Ô∏è –©–∏—Ç: <span id="shieldDisplay">0</span></div>
    <div class="stat-item">üî´ –ü–∞—Ç—Ä–æ–Ω–∏: <span id="ammoDisplay">10</span></div>
    <div class="stat-item">üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ: <span id="zombieCount">0</span></div>
    <div class="stat-item">üèÜ –†—ñ–≤–µ–Ω—å: <span id="levelDisplay">1</span></div>
  </div>

  <div class="maze-container">
    <div class="maze" id="maze"></div>
  </div>
</div>

<div class="winner-overlay" id="winnerOverlay">
  <div class="winner-modal">
    <div class="winner-text" id="winnerText">üèÜ –í–ò–ñ–ò–í!</div>
    <p id="winnerMessage">–í—ñ—Ç–∞—î–º–æ –∑ –≤–∏–∂–∏–≤–∞–Ω–Ω—è–º!</p>
    <button class="btn" id="playAgainBtn">üîÑ –ì—Ä–∞—Ç–∏ –∑–Ω–æ–≤—É</button>
  </div>
</div>

<script>
class MazeGenerator {
  constructor(size) {
    this.size = size;
    this.maze = [];
    this.generate();
  }

  generate() {
    this.maze = Array(this.size).fill().map(() => Array(this.size).fill(1));
    const stack = [];
    const start = [1, 1];
    this.maze[start[0]][start[1]] = 0;
    stack.push(start);

    while (stack.length > 0) {
      const current = stack[stack.length - 1];
      const neighbors = this.getUnvisitedNeighbors(current);

      if (neighbors.length > 0) {
        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
        this.removeWall(current, next);
        this.maze[next[0]][next[1]] = 0;
        stack.push(next);
      } else {
        stack.pop();
      }
    }

    this.maze[this.size - 2][this.size - 2] = 0;
  }

  getUnvisitedNeighbors([row, col]) {
    const neighbors = [];
    const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];

    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;

      if (newRow > 0 && newRow < this.size - 1 &&
        newCol > 0 && newCol < this.size - 1 &&
        this.maze[newRow][newCol] === 1) {
        neighbors.push([newRow, newCol]);
      }
    }

    return neighbors;
  }

  removeWall([row1, col1], [row2, col2]) {
    const wallRow = (row1 + row2) / 2;
    const wallCol = (col1 + col2) / 2;
    this.maze[wallRow][wallCol] = 0;
  }
}

class ZombieApocalypseGame {
  constructor() {
    this.size = 29;
    this.maze = null;
    this.playerPos = [1, 1];
    this.isGameActive = false;
    this.isPaused = false;
    this.startTime = null;
    this.timerInterval = null;
    this.playerDirection = null;
    this.playerMoveInterval = null;
    this.zombies = [];
    this.zombieMoveInterval = null;
    this.eventInterval = null;
    this.itemSpawnInterval = null;
    this.zombieTypeChangeInterval = null;
    this.collisionCheckInterval = null;
    this.playerBlockedUntil = 0;
    
    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≥—Ä–∞–≤—Ü—è
    this.playerHealth = 100;
    this.playerShield = 0;
    this.playerAmmo = 10;
    this.playerLevel = 1;
    this.zombiesKilled = 0;
    this.survivalTime = 0;
    
    // –ü—Ä–µ–¥–º–µ—Ç–∏
    this.ammoPos = null;
    this.ammoVisible = false;
    this.healthPos = null;
    this.healthVisible = false;
    this.shieldPos = null;
    this.shieldVisible = false;
    this.pickaxePos = null;
    this.pickaxeVisible = false;
    this.playerHasPickaxe = false;
    this.knifePos = null;
    this.knifeVisible = false;
    this.playerHasKnife = true; // –ù—ñ–∂ –æ–¥—Ä–∞–∑—É —É –≥—Ä–∞–≤—Ü—è
    this.playerKnifeUses = 0;   // 6 —É–¥–∞—Ä—ñ–≤ –¥–æ—Å—Ç—É–ø–Ω–æ
    this.minePos = null;
    this.mineVisible = false;
    this.playerMines = 0;
    this.mineTimeout = null;
    this.activeMines = [];
    
    // –¢–∞–π–º–µ—Ä–∏ –¥–ª—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
    this.ammoTimeout = null;
    this.healthTimeout = null;
    this.shieldTimeout = null;
    this.pickaxeTimeout = null;
    this.knifeTimeout = null;
    
    // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ —Å–ø–∞–º—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
    this.lastDamageTime = 0;
    this.damageCooldown = 1000; // 1 —Å–µ–∫—É–Ω–¥–∞ –º—ñ–∂ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏ –ø—Ä–æ –ø–æ—à–∫–æ–¥–∂–µ–Ω–Ω—è
    
    // –ë–µ–∑–ø–µ—á–Ω—ñ –∑–æ–Ω–∏
    this.safeZones = [];
    this.safeZoneTimeout = null;
    
    // –í–∏—Ö—ñ–¥ (–∑'—è–≤–ª—è—î—Ç—å—Å—è –ø—ñ—Å–ª—è –≤–±–∏–≤—Å—Ç–≤–∞ –≤—Å—ñ—Ö –∑–æ–º–±—ñ)
    this.exitPos = null;
    this.exitVisible = false;
    
    // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ
    this.difficulty = 'easy';
    this.zombieSpawnRate = 5000;
    this.itemSpawnRate = 8000;
    this.safeZoneRate = 15000;
    
    // –°–∏—Å—Ç–µ–º–∞ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏—Ö –∫–ª–∞–≤—ñ—à —Ä—É—Ö—É
    this.pressedKeys = new Set();
    
    this.initializeElements();
    this.setupEventListeners();
    
    // –î–æ–¥–∞—é –∞—É–¥—ñ–æ-–µ–ª–µ–º–µ–Ω—Ç–∏
    this.audioStart = document.getElementById('audioStart');
    this.audioKnife = document.getElementById('audioKnife');
    this.audioGun = document.getElementById('audioGun');
    this.audioStep = document.getElementById('audioStep');
    this.audioZombie = document.getElementById('audioZombie');
    this.audioPickup = document.getElementById('audioPickup');
    this.audioWin = document.getElementById('audioWin');
    this.audioLose = document.getElementById('audioLose');
    this.audioMineExplosion = document.getElementById('audioMineExplosion');
    this.audioMinePlace = document.getElementById('audioMinePlace');
    this.audioZombieHit = document.getElementById('audioZombieHit');
    this.audioZombieKill = document.getElementById('audioZombieKill');
    this.audioZombieSee = document.getElementById('audioZombieSee');
    this.audioSafeZone = document.getElementById('audioSafeZone');
    this.audioZombieBite = document.getElementById('audioZombieBite');
    this.audioBreakWall = document.getElementById('audioBreakWall');
    this.audioPlayerDeath = document.getElementById('audioPlayerDeath');
    this.audioMineDefuse = document.getElementById('audioMineDefuse');
    this.wasInSafeZone = false;
    
    this.zombieLastSeenState = new Map(); // –î–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—é –∑–≤—É–∫—É –ø–æ—è–≤–∏ —É –ø–æ–ª—ñ –∑–æ—Ä—É
    this.mineDetectorPos = null;
    this.mineDetectorVisible = false;
    this.playerMineDetectorUses = 0;
    this.mineDetectorTimeout = null;
  }

  initializeElements() {
    this.mazeEl = document.getElementById('maze');
    this.playerStatusEl = document.getElementById('playerStatus');
    this.timerEl = document.getElementById('timer');
    this.winnerOverlay = document.getElementById('winnerOverlay');
    this.winnerText = document.getElementById('winnerText');
    this.winnerMessage = document.getElementById('winnerMessage');
    this.newGameBtn = document.getElementById('newGameBtn');
    this.pauseBtn = document.getElementById('pauseBtn');
    this.playAgainBtn = document.getElementById('playAgainBtn');
    this.difficultySelect = document.getElementById('difficultyLevel');
  }

  setupEventListeners() {
    this.newGameBtn.addEventListener('click', () => this.newGame());
    this.pauseBtn.addEventListener('click', () => this.togglePause());
    this.playAgainBtn.addEventListener('click', () => this.newGame());

    document.getElementById('helpBtn').addEventListener('click', () => {
      alert('üßü‚Äç‚ôÇÔ∏è –ó–û–ú–ë–Ü-–ê–ü–û–ö–ê–õ–Ü–ü–°–ò–°: –õ–ê–ë–Ü–†–ò–ù–¢ –í–ò–ñ–ò–í–ê–ù–ù–Ø\n\nüéØ –¶—ñ–ª—å: –ó–Ω–∏—â–∏—Ç–∏ –≤—Å—ñ—Ö –∑–æ–º–±—ñ, —â–æ–± –∑\'—è–≤–∏–≤—Å—è —á–µ—Ä–≤–æ–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç (–≤–∏—Ö—ñ–¥), –ø–æ—Ç—ñ–º –¥—ñ—Å—Ç–∞—Ç–∏—Å—è –¥–æ –Ω—å–æ–≥–æ!\n\nüéÆ –ö–µ—Ä—É–≤–∞–Ω–Ω—è:\n‚Ä¢ –°—Ç—Ä—ñ–ª–∫–∏ ‚Üê‚Üë‚Üì‚Üí –∞–±–æ WASD –¥–ª—è —Ä—É—Ö—É\n‚Ä¢ –ü—Ä–æ–±—ñ–ª –¥–ª—è –∞—Ç–∞–∫–∏ (—Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ —Å—Ç–æ—ó—Ç–µ)\n‚Ä¢ E –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ç–æ–ø–æ—Ä–∞ (—è–∫—â–æ —î)\n\n‚öîÔ∏è –ë–æ–π–æ–≤–∞ —Å–∏—Å—Ç–µ–º–∞:\n‚Ä¢ –ë–ª–∏–∂–Ω—ñ–π –±—ñ–π (–∑–æ–º–±—ñ –Ω–∞ –≤–∞—à—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ): –ü–æ—Ç—Ä—ñ–±–µ–Ω –Ω—ñ–∂, –ø–∞—Ç—Ä–æ–Ω–∏ –Ω–µ –≤–∏—Ç—Ä–∞—á–∞—é—Ç—å—Å—è.\n‚Ä¢ –°—Ç—Ä—ñ–ª—å–±–∞ (–∑–æ–º–±—ñ –Ω–∞ –≤—ñ–¥—Å—Ç–∞–Ω—ñ): –ü–æ—Ç—Ä—ñ–±–Ω—ñ –ø–∞—Ç—Ä–æ–Ω–∏, –Ω—ñ–∂ –Ω–µ –ø–æ—Ç—Ä—ñ–±–µ–Ω.\n‚Ä¢ –ë–µ–∑ –Ω–æ–∂–∞ –Ω–µ–º–æ–∂–ª–∏–≤–æ –∞—Ç–∞–∫—É–≤–∞—Ç–∏ –≤ –±–ª–∏–∂–Ω—å–æ–º—É –±–æ—é!\n‚Ä¢ –ë–µ–∑ –ø–∞—Ç—Ä–æ–Ω—ñ–≤ –Ω–µ–º–æ–∂–ª–∏–≤–æ —Å—Ç—Ä—ñ–ª—è—Ç–∏!\n\nüìã –Ü–Ω—à–µ:\n‚Ä¢ –ó–µ–ª–µ–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç - —Å—Ç–∞—Ä—Ç\n‚Ä¢ –ó–æ–º–±—ñ —Ä—É—Ö–∞—é—Ç—å—Å—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é A* –∞–ª–≥–æ—Ä–∏—Ç–º—É\n‚Ä¢ –ó–±–∏—Ä–∞–π—Ç–µ –ø–∞—Ç—Ä–æ–Ω–∏, –∑–¥–æ—Ä–æ–≤\'—è, —â–∏—Ç–∏ —Ç–∞ —Ç–æ–ø–æ—Ä–∏\n‚Ä¢ –¢–æ–ø–æ—Ä –¥–æ–∑–≤–æ–ª—è—î –ø—Ä–æ—Ä—É–±—É–≤–∞—Ç–∏ —Å—Ç—ñ–Ω–∏ (–∫–Ω–æ–ø–∫–∞ E)\n‚Ä¢ –ë–µ–∑–ø–µ—á–Ω—ñ –∑–æ–Ω–∏ —Ç–∏–º—á–∞—Å–æ–≤–æ –∑–∞—Ö–∏—â–∞—é—Ç—å –≤—ñ–¥ –∑–æ–º–±—ñ\n‚Ä¢ –ó–æ–º–±—ñ –∑\'—è–≤–ª—è—é—Ç—å—Å—è –¢–Ü–õ–¨–ö–ò –ø—Ä–∏ –∫–æ–Ω—Ç–∞–∫—Ç—ñ —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø—ñ–≤\n‚Ä¢ –¢–∏–ø–∏ –∑–æ–º–±—ñ –∑–º—ñ–Ω—é—é—Ç—å—Å—è –∫–æ–∂–Ω—ñ 10 —Å–µ–∫—É–Ω–¥\n‚Ä¢ –ó–¥–æ—Ä–æ–≤\'—è –∑–æ–º–±—ñ: –ó–≤–∏—á–∞–π–Ω–∏–π(2), –®–≤–∏–¥–∫–∏–π(3), –ë–æ—Å(5)');
    });

    // –û–±—Ä–æ–±–Ω–∏–∫–∏ –¥–ª—è –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏—Ö –∫–ª–∞–≤—ñ—à —Ä—É—Ö—É
    document.addEventListener('keydown', (e) => {
      const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'];
      if (movementKeys.includes(e.code)) {
        this.pressedKeys.add(e.code);
        // –û–Ω–æ–≤–ª—é—î–º–æ –Ω–∞–ø—Ä—è–º–æ–∫ —Ä—É—Ö—É –Ω–∞ –æ—Å—Ç–∞–Ω–Ω—é –Ω–∞—Ç–∏—Å–Ω—É—Ç—É –∫–ª–∞–≤—ñ—à—É
        const keyMap = {
          'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
          'ArrowDown': [1, 0], 'KeyS': [1, 0],
          'ArrowLeft': [0, -1], 'KeyA': [0, -1],
          'ArrowRight': [0, 1], 'KeyD': [0, 1]
        };
        this.playerDirection = keyMap[e.code];
      }
      // --- –î–æ–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –¥–ª—è –ø—Ä–æ–±—ñ–ª—É ---
      if (e.code === 'Space') {
        if (!this.spacePressed) {
          this.spacePressed = true;
          this.handleKeyPress(e);
        }
        e.preventDefault();
        return;
      }
      this.handleKeyPress(e);
      // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–∏–Ω—ã –ø–æ X
      if (e.code === 'KeyX') {
        this.tryPlaceMine();
      }
      // --- –î–æ–¥–∞—î–º–æ —Ä–æ–∑–º—ñ–Ω—É–≤–∞–Ω–Ω—è –º—ñ–Ω–∏ –ø–æ R ---
      if (e.code === 'KeyR') {
        this.tryDefuseMine();
      }
    });
    
    document.addEventListener('keyup', (e) => {
      const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'];
      if (movementKeys.includes(e.code)) {
        this.pressedKeys.delete(e.code);
        // –Ø–∫—â–æ –∂–æ–¥–Ω–∞ –∫–ª–∞–≤—ñ—à–∞ –Ω–µ –∑–∞—Ç–∏—Å–Ω—É—Ç–∞ ‚Äî –∑—É–ø–∏–Ω—è—î–º–æ —Ä—É—Ö
        if (this.pressedKeys.size === 0) {
          this.playerDirection = null;
        } else {
          // –Ø–∫—â–æ —â–µ —î –∑–∞—Ç–∏—Å–Ω—É—Ç—ñ ‚Äî —Ä—É—Ö–∞—î–º–æ—Å—è —É –Ω–∞–ø—Ä—è–º–∫—É –æ—Å—Ç–∞–Ω–Ω—å–æ—ó –∑ –Ω–∏—Ö
          const lastKey = Array.from(this.pressedKeys).slice(-1)[0];
          const keyMap = {
            'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
            'ArrowDown': [1, 0], 'KeyS': [1, 0],
            'ArrowLeft': [0, -1], 'KeyA': [0, -1],
            'ArrowRight': [0, 1], 'KeyD': [0, 1]
          };
          this.playerDirection = keyMap[lastKey];
        }
      }
      // --- –°–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –¥–ª—è –ø—Ä–æ–±—ñ–ª—É ---
      if (e.code === 'Space') {
        this.spacePressed = false;
      }
    });
    
    this.difficultySelect.addEventListener('change', (e) => {
      this.difficulty = e.target.value;
      this.updateDifficultySettings();
      this.updateStats();
    });
  }

  updateDifficultySettings() {
    switch(this.difficulty) {
      case 'easy':
        this.zombieSpawnRate = 5000;
        this.itemSpawnRate = 8000;
        this.safeZoneRate = 15000;
        break;
      case 'medium':
        this.zombieSpawnRate = 4000;
        this.itemSpawnRate = 7000;
        this.safeZoneRate = 12000;
        break;
      case 'hard':
        this.zombieSpawnRate = 3000;
        this.itemSpawnRate = 6000;
        this.safeZoneRate = 10000;
        break;
      case 'nightmare':
        this.zombieSpawnRate = 2000;
        this.itemSpawnRate = 5000;
        this.safeZoneRate = 8000;
        break;
    }
  }

  clearAllIntervals() {
    if (this.timerInterval) clearInterval(this.timerInterval);
    if (this.playerMoveInterval) clearInterval(this.playerMoveInterval);
    if (this.zombieMoveInterval) clearInterval(this.zombieMoveInterval);
    if (this.eventInterval) clearInterval(this.eventInterval);
    if (this.itemSpawnInterval) clearInterval(this.itemSpawnInterval);
    if (this.zombieTypeChangeInterval) clearInterval(this.zombieTypeChangeInterval);
    if (this.collisionCheckInterval) clearInterval(this.collisionCheckInterval);
    if (this.ammoTimeout) clearTimeout(this.ammoTimeout);
    if (this.healthTimeout) clearTimeout(this.healthTimeout);
    if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
    if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
    if (this.knifeTimeout) clearTimeout(this.knifeTimeout);
    if (this.safeZoneTimeout) clearTimeout(this.safeZoneTimeout);
    if (this.safeZoneAmmoInterval) clearInterval(this.safeZoneAmmoInterval);
    if (this.safeZoneShieldInterval) clearInterval(this.safeZoneShieldInterval);
    // –°–∫–∏–¥–∞—î–º–æ –Ω–∞—Ç–∏—Å–Ω—É—Ç—ñ –∫–ª–∞–≤—ñ—à—ñ
    this.pressedKeys.clear();
  }

  newGame() {
    this.clearAllIntervals();
    this.isGameActive = true;
    this.isPaused = false;
    this.startTime = Date.now();
    this.playerPos = [1, 1];
    this.playerDirection = null;
    this.activeMines = [];
    
    // –°–∫–∏–¥–∞–Ω–Ω—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    this.playerHealth = 100;
    this.playerShield = 0;
    this.playerAmmo = 10;
    this.playerLevel = 1;
    this.zombiesKilled = 0;
    this.survivalTime = 0;
    
    // –°–∫–∏–¥–∞–Ω–Ω—è –ø—Ä–µ–¥–º–µ—Ç—ñ–≤
    this.ammoPos = null;
    this.ammoVisible = false;
    this.healthPos = null;
    this.healthVisible = false;
    this.shieldPos = null;
    this.shieldVisible = false;
    this.pickaxePos = null;
    this.pickaxeVisible = false;
    this.playerHasPickaxe = false;
    this.knifePos = null;
    this.knifeVisible = false;
    this.playerHasKnife = true; // –ù—ñ–∂ –æ–¥—Ä–∞–∑—É —É –≥—Ä–∞–≤—Ü—è
    this.playerKnifeUses = 0;   // 6 —É–¥–∞—Ä—ñ–≤ –¥–æ—Å—Ç—É–ø–Ω–æ
    this.minePos = null;
    this.mineVisible = false;
    this.playerMines = 0;
    this.safeZones = [];
    this.exitPos = null;
    this.exitVisible = false;
    
    // –°–∫–∏–¥–∞–Ω–Ω—è –∑–∞—Ö–∏—Å—Ç—É –≤—ñ–¥ —Å–ø–∞–º—É
    this.lastDamageTime = 0;
    
    // –û—á–∏—â–µ–Ω–Ω—è —Ç–∞–π–º–µ—Ä—ñ–≤
    if (this.ammoTimeout) clearTimeout(this.ammoTimeout);
    if (this.healthTimeout) clearTimeout(this.healthTimeout);
    if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
    if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
    if (this.knifeTimeout) clearTimeout(this.knifeTimeout);
    if (this.safeZoneTimeout) clearTimeout(this.safeZoneTimeout);
    
    // –°–∫–∏–¥–∞—î–º–æ –Ω–∞—Ç–∏—Å–Ω—É—Ç—ñ –∫–ª–∞–≤—ñ—à—ñ
    this.pressedKeys.clear();
    
    // –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –ª–∞–±—ñ—Ä–∏–Ω—Ç—É
    const generator = new MazeGenerator(this.size);
    this.maze = generator.maze.map(row => [...row]);
    
    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–æ–º–±—ñ
    this.zombies = [];
    this.spawnInitialZombies();
    
    this.renderMaze();
    this.updateStatus('playing');
    this.updateStats();
    this.startTimer();
    this.startPlayerAutoMove();
    this.startZombieAI();
    this.startCollisionCheck();
    this.startItemSpawning();
    this.startSafeZoneSpawning();
    this.startZombieTypeChange();
    this.startRandomMazeEvents();
    
    this.newGameBtn.textContent = 'üîÑ –ù–æ–≤–∞ –≥—Ä–∞';
    this.pauseBtn.disabled = false;
    this.winnerOverlay.style.display = 'none';
    
    if (this.audioStart) { this.audioStart.currentTime = 0; this.audioStart.play(); }
  }

  spawnInitialZombies() {
    const initialZombieCount = this.difficulty === 'easy' ? 3 : 
                              this.difficulty === 'medium' ? 5 :
                              this.difficulty === 'hard' ? 9 : 12;
    
    for (let i = 0; i < initialZombieCount; i++) {
      this.spawnZombie();
    }
  }

  spawnZombie() {
    const pos = this.getRandomEmptyPosition();
    if (!pos) return; // –ù–µ —Å–ø–∞–≤–Ω–∏—Ç–∏, —è–∫—â–æ –Ω–µ–º–∞—î –º—ñ—Å—Ü—è
    const zombieType = Math.random() < 0.1 ? 'boss' : 
                      Math.random() < 0.3 ? 'fast' : 'normal';
    
    let health;
    switch(zombieType) {
      case 'boss': health = 5; break;
      case 'fast': health = 3; break;
      default: health = 2; break;
    }
    
    this.zombies.push({
      pos: pos,
      type: zombieType,
      health: health,
      maxHealth: health,
      speed: zombieType === 'fast' ? 80 : zombieType === 'boss' ? 220 : 140,
      state: 'patrolling',
      direction: [0, 1],
      path: [],
      pathIndex: 0,
      lastMoveTime: Date.now(),
      stunnedUntil: 0,
      lastShotTime: 0,
      // === –ù–û–í–ò–ô –Ü–ù–í–ï–ù–¢–ê–† –ó–û–ú–ë–Ü ===
      inventory: {
        shield: 0,
        ammo: 0,
        level: 1,
        hasPickaxe: false,
        hasKnife: false,
        mines: 0,
        mineDetectorUses: 0
      }
    });
  }

  getRandomEmptyPosition() {
    let row, col, attempts = 0;
    do {
      row = Math.floor(Math.random() * (this.size - 2)) + 1;
      col = Math.floor(Math.random() * (this.size - 2)) + 1;
      attempts++;
      if (attempts > 1000) return null; // –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –≤—ñ–ª—å–Ω–æ–≥–æ –º—ñ—Å—Ü—è
    } while (
      this.maze[row][col] === 1 ||
      (row === this.playerPos[0] && col === this.playerPos[1]) ||
      this.zombies.some(z => z.pos[0] === row && z.pos[1] === col) ||
      this.safeZones.some(sz => sz[0] === row && sz[1] === col)
    );
    return [row, col];
  }

  renderMaze() {
    this.mazeEl.innerHTML = '';
    this.mazeEl.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
    
    for (let row = 0; row < this.size; row++) {
      for (let col = 0; col < this.size; col++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        
        if (this.maze[row][col] === 1) {
          cell.classList.add('wall');
        } else {
          cell.classList.add('path');
        }
        
        if (row === 1 && col === 1) cell.classList.add('start');
        
        if (this.exitVisible && this.exitPos && row === this.exitPos[0] && col === this.exitPos[1]) {
          cell.classList.add('end');
        }
        
        if (row === this.playerPos[0] && col === this.playerPos[1]) {
          cell.classList.add('player');
        }
        
        for (const zombie of this.zombies) {
          if (row === zombie.pos[0] && col === zombie.pos[1]) {
            cell.classList.add('zombie');
            if (zombie.type === 'fast') cell.classList.add('zombie-fast');
            if (zombie.type === 'boss') {
              cell.classList.add('zombie-boss');
              cell.innerHTML = '<span style="font-size:15px;">üíÄ</span>';
            }
            if (zombie.health < zombie.maxHealth) {
              const healthPercent = (zombie.health / zombie.maxHealth) * 100;
              let healthColor = healthPercent < 25 ? '#ff0000' : healthPercent < 50 ? '#ffff00' : '#00ff00';
              cell.style.border = `2px solid ${healthColor}`;
              cell.style.boxShadow = `0 0 8px ${healthColor}`;
            }
          }
        }
        
        if (this.ammoVisible && this.ammoPos && row === this.ammoPos[0] && col === this.ammoPos[1]) {
          cell.classList.add('ammo-cell');
          cell.innerHTML = '<span style="font-size:12px;">üî´</span>';
        }
        
        if (this.healthVisible && this.healthPos && row === this.healthPos[0] && col === this.healthPos[1]) {
          cell.classList.add('health-cell');
          cell.innerHTML = '<span style="font-size:12px;">‚ù§Ô∏è</span>';
        }
        
        if (this.shieldVisible && this.shieldPos && row === this.shieldPos[0] && col === this.shieldPos[1]) {
          cell.classList.add('shield-cell');
          cell.innerHTML = '<span style="font-size:12px;">üõ°Ô∏è</span>';
        }
        
        if (this.pickaxeVisible && this.pickaxePos && row === this.pickaxePos[0] && col === this.pickaxePos[1]) {
          cell.classList.add('pickaxe-cell');
          cell.innerHTML = '<span style="font-size:12px;">ü™ì</span>';
        }
        
        if (this.knifeVisible && this.knifePos && row === this.knifePos[0] && col === this.knifePos[1]) {
          cell.classList.add('knife-cell');
          cell.innerHTML = '<span style="font-size:12px;">üî™</span>';
        }
        
        if (this.safeZones.some(sz => sz[0] === row && sz[1] === col)) {
          cell.classList.add('safe-zone');
        }
        
        if (this.mineVisible && this.minePos && row === this.minePos[0] && col === this.minePos[1]) {
          cell.classList.add('mine-cell', 'mine-item');
          cell.innerHTML = '<span style="font-size:13px;">üí£</span>';
        }
        
        const activeMine = this.activeMines.find(m => m.pos[0] === row && m.pos[1] === col);
        if (activeMine) {
            cell.classList.add('mine-cell');
            if (activeMine.placedBy === 'player') {
                cell.style.border = '2px solid #ff2222';
            } else { // Zombie mine
                cell.classList.add('zombie-mine-cell');
            }
        }
        
        if (this.mineDetectorVisible && this.mineDetectorPos && row === this.mineDetectorPos[0] && col === this.mineDetectorPos[1]) {
          cell.classList.add('mine-detector-cell');
          cell.innerHTML = '<span style="font-size:13px;">üß∞</span>';
        }
        
        this.mazeEl.appendChild(cell);
      }
    }
  }

  handleKeyPress(e) {
    if (!this.isGameActive || this.isPaused) return;
    
    const keyMap = {
      'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
      'ArrowDown': [1, 0], 'KeyS': [1, 0],
      'ArrowLeft': [0, -1], 'KeyA': [0, -1],
      'ArrowRight': [0, 1], 'KeyD': [0, 1]
    };
    
    const direction = keyMap[e.code];
    if (direction) {
      e.preventDefault();
      this.playerDirection = direction;
    }
    
    if (e.code === 'Space') {
      e.preventDefault();
      this.shoot();
    }
    
    if (e.code === 'KeyE' && this.playerHasPickaxe) {
      this.tryBreakWall();
    }
  }

  shoot() {
    const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'];
    const isMoving = movementKeys.some(key => this.pressedKeys.has(key));
    
    const inSafeZone = this.safeZones.some(sz => 
      sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]
    );
    if (inSafeZone) {
      this.showEventNotification('‚ùå –£ –±–µ–∑–ø–µ—á–Ω—ñ–π –∑–æ–Ω—ñ –Ω–µ –º–æ–∂–Ω–∞ –∞—Ç–∞–∫—É–≤–∞—Ç–∏!');
      return;
    }
    
    if (isMoving) {
      this.showEventNotification('‚ùå –ù–µ –º–æ–∂–Ω–∞ —Å—Ç—Ä—ñ–ª—è—Ç–∏ –ø—ñ–¥ —á–∞—Å —Ä—É—Ö—É! –ó—É–ø–∏–Ω—ñ—Ç—å—Å—è!');
      return;
    }
    
    const zombieOnPlayer = this.zombies.findIndex(z => 
      z.pos[0] === this.playerPos[0] && z.pos[1] === this.playerPos[1]
    );
    
    if (zombieOnPlayer !== -1) {
      if (this.playerHasKnife) {
        this.meleeAttack();
      } else {
        this.showEventNotification('‚ùå –ü–æ—Ç—Ä—ñ–±–µ–Ω –Ω—ñ–∂ –¥–ª—è –±–ª–∏–∂–Ω—å–æ–≥–æ –±–æ—é!');
      }
    } else {
      if (this.playerAmmo > 0) {
        this.rangedAttack();
      } else {
        this.showEventNotification('‚ùå –ù–µ–º–∞—î –ø–∞—Ç—Ä–æ–Ω—ñ–≤ –¥–ª—è —Å—Ç—Ä—ñ–ª—å–±–∏!');
      }
    }
  }

  meleeAttack() {
    const inSafeZone = this.safeZones.some(sz => 
      sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]
    );
    if (inSafeZone) return;
    if (!this.playerHasKnife) {
      this.showEventNotification('‚ùå –ü–æ—Ç—Ä—ñ–±–µ–Ω –Ω—ñ–∂ –¥–ª—è –±–ª–∏–∂–Ω—å–æ–≥–æ –±–æ—é!');
      return;
    }
    if (this.playerKnifeUses >= 6) {
      this.showEventNotification('üî™ –ù—ñ–∂ –∑–ª–∞–º–∞–≤—Å—è! –ü–æ—Ç—Ä—ñ–±–µ–Ω –Ω–æ–≤–∏–π –Ω—ñ–∂!');
      this.playerHasKnife = false;
      this.playerKnifeUses = 0;
      this.updateStats();
      return;
    }
    
    const zombieOnPlayer = this.zombies.findIndex(z => 
      z.pos[0] === this.playerPos[0] && z.pos[1] === this.playerPos[1]
    );
    
    if (zombieOnPlayer !== -1) {
      // –ó–±—ñ–ª—å—à—É—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω—å –Ω–æ–∂–∞ –ü–ï–†–ï–î –∞—Ç–∞–∫–æ—é
      this.playerKnifeUses++;
      
      if (Math.random() < 0.65) {
        const zombie = this.zombies[zombieOnPlayer];
        zombie.health--;
        if (this.audioZombieHit) { this.audioZombieHit.currentTime = 0; this.audioZombieHit.play(); }
        if (zombie.health <= 0) {
          this.zombies.splice(zombieOnPlayer, 1);
          this.zombiesKilled++;
          if (this.audioZombieKill) { this.audioZombieKill.currentTime = 0; this.audioZombieKill.play(); }
          
          if (this.zombies.length === 0) {
            this.spawnExit();
            this.showEventNotification('üèÜ –í—Å—ñ –∑–æ–º–±—ñ –∑–Ω–∏—â–µ–Ω—ñ! –ó–Ω–∞–π–¥—ñ—Ç—å –≤–∏—Ö—ñ–¥!');
          }
        }
        this.renderMaze();
        this.updateStats();
      } else {
        this.showEventNotification('üî™ –ü—Ä–æ–º–∞—Ö!');
      }
    } else {
      this.showEventNotification('‚ùå –ù–µ–º–∞—î –∑–æ–º–±—ñ –¥–ª—è –∞—Ç–∞–∫–∏ –Ω–æ–∂–µ–º!');
    }
    
    if (this.audioKnife) { this.audioKnife.currentTime = 0; this.audioKnife.play(); }
  }

  rangedAttack() {
    if (this.playerAmmo <= 0) {
      this.showEventNotification('‚ùå –ù–µ–º–∞—î –ø–∞—Ç—Ä–æ–Ω—ñ–≤ –¥–ª—è —Å—Ç—Ä—ñ–ª—å–±–∏!');
      return;
    }
    
    this.playerAmmo--;
    this.updateStats();
    
    if (Math.random() >= 0.5) {
      this.showEventNotification('üî´ –ü—Ä–æ–º–∞—Ö!');
      return;
    }
    
    const target = this.findZombieInLineOfSight();
    
    if (target) {
      const zombie = this.zombies[target.index];
      zombie.health--;
      if (this.audioZombieHit) { this.audioZombieHit.currentTime = 0; this.audioZombieHit.play(); }
      if (zombie.health <= 0) {
        this.zombies.splice(target.index, 1);
        this.zombiesKilled++;
        if (this.audioZombieKill) { this.audioZombieKill.currentTime = 0; this.audioZombieKill.play(); }
        
        if (this.zombies.length === 0) {
          this.spawnExit();
          this.showEventNotification('üèÜ –í—Å—ñ –∑–æ–º–±—ñ –∑–Ω–∏—â–µ–Ω—ñ! –ó–Ω–∞–π–¥—ñ—Ç—å –≤–∏—Ö—ñ–¥!');
        }
      } else {
        // –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø—Ä–æ–º–∞—Ö –ø—Ä–∏–±—Ä–∞–Ω–æ
      }
      this.renderMaze();
      this.updateStats();
    } else {
      this.showEventNotification('üî´ –ü—Ä–æ–º–∞—Ö!');
    }
    
    if (this.audioGun) { this.audioGun.currentTime = 0; this.audioGun.play(); }
  }

  findZombieInLineOfSight() {
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    let closestTarget = null;
    let closestDistance = Infinity;
    
    for (const [dr, dc] of directions) {
      let r = this.playerPos[0] + dr;
      let c = this.playerPos[1] + dc;
      let distance = 1;
      
      while (r >= 0 && r < this.size && c >= 0 && c < this.size && this.maze[r][c] === 0) {
        const zombieIndex = this.zombies.findIndex(z => z.pos[0] === r && z.pos[1] === c);
        if (zombieIndex !== -1) {
          if (distance < closestDistance) {
            closestTarget = { index: zombieIndex, distance: distance };
            closestDistance = distance;
          }
          break;
        }
        r += dr;
        c += dc;
        distance++;
      }
    }
    
    return closestTarget;
  }

  startPlayerAutoMove() {
    if (this.playerMoveInterval) clearInterval(this.playerMoveInterval);
    this.playerMoveInterval = setInterval(() => {
      if (!this.isGameActive || this.isPaused || Date.now() < this.playerBlockedUntil) return;
      this.checkSafeZone();
      if (!this.playerDirection) return;
      const newRow = this.playerPos[0] + this.playerDirection[0];
      const newCol = this.playerPos[1] + this.playerDirection[1];
      if (this.isValidMove(newRow, newCol, 'player')) {
        this.playerPos = [newRow, newCol];
        if (this.audioStep) { this.audioStep.currentTime = 0; this.audioStep.play(); }
        this.checkItemPickup();
        this.checkSafeZone();
        this.renderMaze();
      }
    }, 100);
  }

  isValidMove(row, col, entityType = 'zombie') {
    if (!(row >= 0 && row < this.size && col >= 0 && col < this.size && this.maze[row][col] === 0)) {
        return false;
    }
    // –ó–∞–±–æ—Ä–æ–Ω–∞ –¥–ª—è –∑–æ–º–±—ñ –∑–∞—Ö–æ–¥–∏—Ç–∏ —É –∑–æ–Ω—É –±–µ–∑–ø–µ–∫–∏
    if (entityType === 'zombie' && this.safeZones.some(sz => sz[0] === row && sz[1] === col)) {
        return false;
    }
    return true;
  }

  checkItemPickup() {
    let picked = false;
    // –ì—Ä–∞–≤–µ—Ü—å –ø—ñ–¥–±–∏—Ä–∞—î –ø—Ä–µ–¥–º–µ—Ç–∏
    if (this.ammoVisible && this.ammoPos && this.playerPos[0] === this.ammoPos[0] && this.playerPos[1] === this.ammoPos[1]) {
      this.playerAmmo += 5;
      this.hideAmmo(); picked = true;
    }
    if (this.healthVisible && this.healthPos && this.playerPos[0] === this.healthPos[0] && this.playerPos[1] === this.healthPos[1]) {
      this.playerHealth = Math.min(100, this.playerHealth + 25);
      this.hideHealth(); picked = true;
    }
    if (this.shieldVisible && this.shieldPos && this.playerPos[0] === this.shieldPos[0] && this.playerPos[1] === this.shieldPos[1]) {
      this.playerShield = Math.min(100, this.playerShield + 50);
      this.hideShield(); picked = true;
    }
    if (this.pickaxeVisible && this.pickaxePos && this.playerPos[0] === this.pickaxePos[0] && this.playerPos[1] === this.pickaxePos[1]) {
      this.playerHasPickaxe = true;
      this.hidePickaxe(); picked = true;
    }
    if (this.knifeVisible && this.knifePos && this.playerPos[0] === this.knifePos[0] && this.playerPos[1] === this.knifePos[1]) {
      this.playerHasKnife = true;
      this.playerKnifeUses = 0; // –°–∫–∏–¥–∞—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –ø—Ä–∏ –ø—ñ–¥–±–æ—Ä—ñ –Ω–æ–≤–æ–≥–æ –Ω–æ–∂–∞
      this.hideKnife(); picked = true;
    }
    if (this.mineVisible && this.minePos && this.playerPos[0] === this.minePos[0] && this.playerPos[1] === this.minePos[1]) {
      this.playerMines += 1;
      this.hideMine(); picked = true;
    }
    // --- –î–æ–¥–∞—î–º–æ –ø—ñ–¥–±—ñ—Ä –º—ñ–Ω–Ω–æ–≥–æ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –≥—Ä–∞–≤—Ü–µ–º ---
    if (this.mineDetectorVisible && this.mineDetectorPos && this.playerPos[0] === this.mineDetectorPos[0] && this.playerPos[1] === this.mineDetectorPos[1]) {
      this.playerMineDetectorUses = 3;
      this.hideMineDetector(); picked = true;
      this.showEventNotification('üß∞ –í–∏ –ø—ñ–¥—ñ–±—Ä–∞–ª–∏ –¥–µ—Ç–µ–∫—Ç–æ—Ä –º—ñ–Ω!');
    }
    if (picked) {
        if (this.audioPickup) { this.audioPickup.currentTime = 0; this.audioPickup.play(); }
        this.updateStats();
        this.renderMaze();
    }
  }

  zombieCheckItemPickup(zombie) {
      let picked = false;
      if (this.ammoVisible && this.ammoPos && zombie.pos[0] === this.ammoPos[0] && zombie.pos[1] === this.ammoPos[1]) {
          zombie.inventory.ammo += 5;
          this.hideAmmo(); picked = true;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—ñ–¥—ñ–±—Ä–∞–≤ –ø–∞—Ç—Ä–æ–Ω–∏!');
      }
      if (this.healthVisible && this.healthPos && zombie.pos[0] === this.healthPos[0] && zombie.pos[1] === this.healthPos[1]) {
          zombie.health = Math.min(zombie.maxHealth, zombie.health + 1); // –ó–æ–º–±—ñ –≤—ñ–¥–Ω–æ–≤–ª—é—î 1 HP
          this.hideHealth(); picked = true;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—ñ–¥—ñ–±—Ä–∞–≤ –∑–¥–æ—Ä–æ–≤\'—è!');
      }
      if (this.shieldVisible && this.shieldPos && zombie.pos[0] === this.shieldPos[0] && zombie.pos[1] === this.shieldPos[1]) {
          zombie.inventory.shield += 50;
          this.hideShield(); picked = true;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—ñ–¥—ñ–±—Ä–∞–≤ —â–∏—Ç!');
      }
      if (this.pickaxeVisible && this.pickaxePos && zombie.pos[0] === this.pickaxePos[0] && zombie.pos[1] === this.pickaxePos[1]) {
          zombie.inventory.hasPickaxe = true;
          this.hidePickaxe(); picked = true;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—ñ–¥—ñ–±—Ä–∞–≤ —Ç–æ–ø–æ—Ä!');
      }
      if (this.knifeVisible && this.knifePos && zombie.pos[0] === this.knifePos[0] && zombie.pos[1] === this.knifePos[1]) {
          zombie.inventory.hasKnife = true;
          this.hideKnife(); picked = true;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—ñ–¥—ñ–±—Ä–∞–≤ –Ω—ñ–∂!');
      }
      if (this.mineVisible && this.minePos && zombie.pos[0] === this.minePos[0] && zombie.pos[1] === this.minePos[1]) {
          zombie.inventory.mines += 1;
          this.hideMine(); picked = true;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—ñ–¥—ñ–±—Ä–∞–≤ –º—ñ–Ω—É!');
      }
      if (this.mineDetectorVisible && this.mineDetectorPos && zombie.pos[0] === this.mineDetectorPos[0] && zombie.pos[1] === this.mineDetectorPos[1]) {
          zombie.inventory.mineDetectorUses = 3;
          this.hideMineDetector(); picked = true;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—ñ–¥—ñ–±—Ä–∞–≤ –¥–µ—Ç–µ–∫—Ç–æ—Ä –º—ñ–Ω!');
      }
      if (picked) {
          if (this.audioPickup) { this.audioPickup.currentTime = 0; this.audioPickup.play(); }
          this.renderMaze();
      }
  }

  checkSafeZone() {
    const inSafeZone = this.safeZones.some(sz => 
      sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]
    );
    if (inSafeZone && !this.wasInSafeZone) {
      if (this.audioSafeZone) { this.audioSafeZone.currentTime = 0; this.audioSafeZone.play(); }
    }
    this.wasInSafeZone = inSafeZone;
    
    if (inSafeZone) {
      this.playerStatusEl.textContent = 'üîã –ó–æ–Ω–∞ –ø–æ–ø–æ–≤–Ω–µ–Ω–Ω—è —Ä–µ—Å—É—Ä—Å—ñ–≤! –°—Ç—ñ–π—Ç–µ –Ω–µ—Ä—É—Ö–æ–º–æ!';
      this.playerStatusEl.style.background = 'rgba(46, 204, 113, 0.8)';
      if (!this.safeZoneAmmoInterval) {
        this.safeZoneAmmoInterval = setInterval(() => {
          if (!this.isGameActive || this.isPaused) return;
          const stillInSafeZone = this.safeZones.some(sz => sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]);
          const isMoving = !!this.playerDirection;
          if (stillInSafeZone && !isMoving) {
            this.playerAmmo += 1; this.updateStats(); this.showEventNotification('üî´ +1 –ø–∞—Ç—Ä–æ–Ω (–∑–æ–Ω–∞)');
          }
        }, 2000);
      }
      if (!this.safeZoneShieldInterval) {
        this.safeZoneShieldInterval = setInterval(() => {
          if (!this.isGameActive || this.isPaused) return;
          const stillInSafeZone = this.safeZones.some(sz => sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]);
          const isMoving = !!this.playerDirection;
          if (stillInSafeZone && !isMoving) {
            this.playerShield = Math.min(100, this.playerShield + 10); this.updateStats(); this.showEventNotification('üõ°Ô∏è +10 —â–∏—Ç–∞ (–∑–æ–Ω–∞)');
          }
        }, 3000);
      }
    } else {
      this.playerStatusEl.textContent = 'üßü‚Äç‚ôÇÔ∏è –í–∏–∂–∏–≤–∞—î...';
      this.playerStatusEl.style.background = 'rgba(52, 152, 219, 0.8)';
      if (this.safeZoneAmmoInterval) { clearInterval(this.safeZoneAmmoInterval); this.safeZoneAmmoInterval = null; }
      if (this.safeZoneShieldInterval) { clearInterval(this.safeZoneShieldInterval); this.safeZoneShieldInterval = null; }
    }
  }

  startZombieAI() {
    if (this.zombieMoveInterval) clearInterval(this.zombieMoveInterval);
    
    setTimeout(() => {
      if (!this.isGameActive) return;
      this.zombieMoveInterval = setInterval(() => {
        if (!this.isGameActive || this.isPaused) return;
        this.moveZombies();
      }, 50);
    }, 2000);
  }

  startCollisionCheck() {
    if (this.collisionCheckInterval) clearInterval(this.collisionCheckInterval);
    
    this.collisionCheckInterval = setInterval(() => {
      if (!this.isGameActive || this.isPaused) return;
      this.checkCollision();
    }, 50);
  }

  moveZombies() {
  const now = Date.now();
  for (const zombie of this.zombies) {
    if (!zombie.lastMoveTime) zombie.lastMoveTime = now;
    if (zombie.stunnedUntil && now < zombie.stunnedUntil) continue;
    // --- –Ω–æ–≤–∞ –ª–æ–≥—ñ–∫–∞ ---
    // –î–æ–¥–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É: —è–∫—â–æ –∑–æ–º–±—ñ –Ω–∞ –æ–¥–Ω—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ –∑ –≥—Ä–∞–≤—Ü–µ–º ‚Äî –Ω–µ —Å—Ç—Ä—ñ–ª—è—î!
    if (
      this.canSeeTarget(zombie, this.maze, this.playerPos) &&
      zombie.inventory.ammo > 0 &&
      !(zombie.pos[0] === this.playerPos[0] && zombie.pos[1] === this.playerPos[1])
    ) {
      // –Ø–∫—â–æ –±–∞—á–∏—Ç—å –≥—Ä–∞–≤—Ü—è —ñ —î –ø–∞—Ç—Ä–æ–Ω–∏ ‚Äî –Ω–µ —Ä—É—Ö–∞—î—Ç—å—Å—è, –∞ —Å—Ç—Ä—ñ–ª—è—î
      if (now - zombie.lastShotTime > 142) {
        zombie.lastShotTime = now;
        setTimeout(() => this.zombieShoot(zombie), 200);
      }
      continue; // –ù–µ —Ä—É—Ö–∞—î—Ç—å—Å—è!
    }
    // --- –∫—ñ–Ω–µ—Ü—å –Ω–æ–≤–æ—ó –ª–æ–≥—ñ–∫–∏ ---
    if (now - zombie.lastMoveTime >= zombie.speed) {
      this.moveSingleZombie(zombie);
      zombie.lastMoveTime = now;
      if (Math.abs(zombie.pos[0] - this.playerPos[0]) + Math.abs(zombie.pos[1] - this.playerPos[1]) <= 2) {
        if (this.audioZombie) { this.audioZombie.currentTime = 0; this.audioZombie.play(); }
      }
    }
  }
  this.checkZombieInteractions(this.zombies, this.maze);
  this.renderMaze();
  this.updateStats();
  this.checkMinesExplosion();
  this.checkPlayerMineExplosion();
}
  
  moveSingleZombie(zombie) {
      // 1. –õ–æ–≥—ñ–∫–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ç–æ–ø–æ—Ä–∞
      const nextPosOnPath = this.getNextStepOnPath(zombie);
      if (nextPosOnPath && this.maze[nextPosOnPath[0]][nextPosOnPath[1]] === 1) {
          if (zombie.inventory.hasPickaxe) {
              this.maze[nextPosOnPath[0]][nextPosOnPath[1]] = 0;
              zombie.inventory.hasPickaxe = false;
              zombie.pos = nextPosOnPath;
              if (this.audioBreakWall) { this.audioBreakWall.currentTime = 0; this.audioBreakWall.play(); }
              this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—Ä–æ—Ä—É–±–∞–≤ —Å—Ç—ñ–Ω—É!');
              this.zombies.forEach(z => { z.path = []; z.pathIndex = 0; });
              this.zombieCheckItemPickup(zombie);
              return;
          }
      }

      // 2. –û—Å–Ω–æ–≤–Ω–∏–π —Ä—É—Ö
      this.moveZombiesGeneric([zombie], this.maze, this.playerPos);

      // 3. –ü—ñ–¥–±—ñ—Ä –ø—Ä–µ–¥–º–µ—Ç—ñ–≤ –ø—ñ—Å–ª—è —Ä—É—Ö—É
      this.zombieCheckItemPickup(zombie);

      // 4. –í—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –º—ñ–Ω–∏
      if (zombie.inventory.mines > 0 && zombie.state === 'patrolling' && Math.random() < 0.05) {
          this.tryPlaceZombieMine(zombie);
      }

      // 5. –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ —Ä–æ–∑–º—ñ–Ω—É–≤–∞–Ω–Ω—è –º—ñ–Ω –≥—Ä–∞–≤—Ü—è
      if (zombie.inventory.mineDetectorUses > 0) {
        const mineIdx = this.activeMines.findIndex(m => m.pos[0] === zombie.pos[0] && m.pos[1] === zombie.pos[1] && m.placedBy === 'player');
        if (mineIdx !== -1) {
          this.activeMines.splice(mineIdx, 1);
          zombie.inventory.mineDetectorUses--;
          this.showEventNotification('üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ —Ä–æ–∑–º—ñ–Ω—É–≤–∞–≤ –º—ñ–Ω—É –≥—Ä–∞–≤—Ü—è!');
          this.renderMaze();
          if (this.audioMineDefuse) { this.audioMineDefuse.currentTime = 0; this.audioMineDefuse.play(); }
        }
      }
  }

  getNextStepOnPath(zombie) {
      if (zombie.path && zombie.pathIndex < zombie.path.length) {
          return zombie.path[zombie.pathIndex];
      }
      return null;
  }
    
  zombieShoot(zombie) {
    if (!this.isGameActive || this.isPaused || zombie.inventory.ammo <= 0) return;
    
    zombie.inventory.ammo--;
    // if (this.audioGun) { this.audioGun.currentTime = 0; this.audioGun.play(); } // –≤–∏–¥–∞–ª—è—î–º–æ —Ü–µ–π —Ä—è–¥–æ–∫

    // –¢–∞–∫–∞ –∂ –≤—ñ—Ä–æ–≥—ñ–¥–Ω—ñ—Å—Ç—å –ø–æ–ø–∞–¥–∞–Ω–Ω—è, —è–∫ —É –≥—Ä–∞–≤—Ü—è (50% —à–∞–Ω—Å)
    if (Math.random() >= 0.5) {
        if (this.audioGun) { this.audioGun.currentTime = 0; this.audioGun.play(); } // –¥–æ–¥–∞—î–º–æ —Å—é–¥–∏
        this.showEventNotification(`üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –≤–ª—É—á–∏–≤ —É –≤–∞—Å!`);
        let damage = 15;
        if (zombie.inventory && zombie.inventory.hasKnife) {
          damage = Math.round(damage * 1.5); // +50% —É—Ä–æ–Ω—É
        }
        if (this.playerShield > 0) {
            const shieldDamage = Math.min(this.playerShield, damage);
            this.playerShield -= shieldDamage;
            const remainingDamage = damage - shieldDamage;
            this.playerHealth -= remainingDamage;
        } else {
            this.playerHealth -= damage;
        }
        this.updateStats();
        if (this.playerHealth <= 0) {
            this.endGame(false);
        }
    } else {
        this.showEventNotification(`üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ –ø—Ä–æ–º–∞—Ö–Ω—É–≤—Å—è!`);
    }
  }

  moveZombiesGeneric(zombies, maze, targetPos) {
    for (const zombie of zombies) {
      if (zombie.path && zombie.pathIndex < zombie.path.length) {
        const nextPos = zombie.path[zombie.pathIndex];
        if (!this.isValidMove(nextPos[0], nextPos[1], 'zombie') || (this.isStartActive && nextPos[0] === 1 && nextPos[1] === 1)) {
          zombie.path = []; zombie.pathIndex = 0;
        }
      }

      const prevState = this.zombieLastSeenState.get(zombie) || 'patrolling';
      if (this.canSeeTarget(zombie, maze, targetPos)) {
        zombie.state = 'chasing';
        if (prevState !== 'chasing') { if (this.audioZombieSee) { this.audioZombieSee.currentTime = 0; this.audioZombieSee.play(); } }
      } else {
        zombie.state = 'patrolling';
      }
      this.zombieLastSeenState.set(zombie, zombie.state);

      if (zombie.state === 'chasing') {
        if (!zombie.path || zombie.pathIndex >= zombie.path.length || Math.random() < 0.1) {
          zombie.path = this.findPathAStarWithStartBlock(maze, zombie.pos, targetPos, 'zombie');
          zombie.pathIndex = 1;
        }
        if (zombie.path && zombie.pathIndex < zombie.path.length) {
          if (!(this.isStartActive && zombie.path[zombie.pathIndex][0] === 1 && zombie.path[zombie.pathIndex][1] === 1)) {
            zombie.pos = zombie.path[zombie.pathIndex];
          }
          zombie.pathIndex++;
        }
      } else {
        const possibleDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        const prevDirection = zombie.direction;
        const reverseDirection = prevDirection ? [-prevDirection[0], -prevDirection[1]] : null;
        let validDirections = possibleDirections.filter(dir => {
          const checkPos = [zombie.pos[0] + dir[0], zombie.pos[1] + dir[1]];
          if (this.isStartActive && checkPos[0] === 1 && checkPos[1] === 1) return false;
          if (reverseDirection && dir[0] === reverseDirection[0] && dir[1] === reverseDirection[1]) return false;
          return this.isValidMove(checkPos[0], checkPos[1], 'zombie');
        });
        if (validDirections.length === 0 && reverseDirection) {
          const backPos = [zombie.pos[0] + reverseDirection[0], zombie.pos[1] + reverseDirection[1]];
          if (this.isValidMove(backPos[0], backPos[1], 'zombie') && !(this.isStartActive && backPos[0] === 1 && backPos[1] === 1)) {
            validDirections = [reverseDirection];
          }
        }
        if (validDirections.length > 1 && Math.random() < 0.3) {
          zombie.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
        } else if (validDirections.length > 0) {
          const nextPos = [zombie.pos[0] + (zombie.direction ? zombie.direction[0] : 0), zombie.pos[1] + (zombie.direction ? zombie.direction[1] : 0)];
          if (!zombie.direction || !this.isValidMove(nextPos[0], nextPos[1], 'zombie') || (this.isStartActive && nextPos[0] === 1 && nextPos[1] === 1)) {
            zombie.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
          }
        }
        if (zombie.direction) {
          const nextPos = [zombie.pos[0] + zombie.direction[0], zombie.pos[1] + zombie.direction[1]];
          if (!(this.isStartActive && nextPos[0] === 1 && nextPos[1] === 1)) {
            zombie.pos = nextPos;
          }
        }
      }
    }
  }

  canSeeTarget(zombie, maze, targetPos) {
    if (targetPos[0] === 1 && targetPos[1] === 1) return false;
    const [zRow, zCol] = zombie.pos;
    const [tRow, tCol] = targetPos;
    const lineOfSightDistance = 15;
    if (zRow === tRow && Math.abs(zCol - tCol) < lineOfSightDistance) {
      const start = Math.min(zCol, tCol);
      const end = Math.max(zCol, tCol);
      let wallFound = false;
      for (let i = start + 1; i < end; i++) { if (maze[zRow][i] === 1) { wallFound = true; break; } }
      if (!wallFound) return true;
    }
    if (zCol === tCol && Math.abs(zRow - tRow) < lineOfSightDistance) {
      const start = Math.min(zRow, tRow);
      const end = Math.max(zRow, tRow);
      let wallFound = false;
      for (let i = start + 1; i < end; i++) { if (maze[i][zCol] === 1) { wallFound = true; break; } }
      if (!wallFound) return true;
    }
    return false;
  }

  findPathAStarWithStartBlock(maze, start, goal, entityType = 'zombie') {
    const size = this.size;
    const openSet = [start];
    const cameFrom = {};
    const gScore = Array(size).fill().map(() => Array(size).fill(Infinity));
    const fScore = Array(size).fill().map(() => Array(size).fill(Infinity));
    gScore[start[0]][start[1]] = 0;
    fScore[start[0]][start[1]] = this.heuristic(start, goal);

    function posToStr(pos) { return pos[0] + ',' + pos[1]; }
    function strToPos(str) { return str.split(',').map(Number); }

    while (openSet.length > 0) {
      let currentIdx = 0;
      for (let i = 1; i < openSet.length; i++) {
        if (fScore[openSet[i][0]][openSet[i][1]] < fScore[openSet[currentIdx][0]][openSet[currentIdx][1]]) {
          currentIdx = i;
        }
      }
      const current = openSet.splice(currentIdx, 1)[0];
      if (current[0] === goal[0] && current[1] === goal[1]) {
        let path = [goal]; let currStr = posToStr(goal);
        while (cameFrom[currStr]) { currStr = cameFrom[currStr]; path.push(strToPos(currStr)); }
        return path.reverse();
      }
      const directions = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr, dc] of directions) {
        const nr = current[0] + dr, nc = current[1] + dc;
        if (this.isValidMove(nr, nc, entityType) && !(this.isStartActive && nr === 1 && nc === 1)) {
          const tentative_gScore = gScore[current[0]][current[1]] + 1;
          if (tentative_gScore < gScore[nr][nc]) {
            cameFrom[posToStr([nr, nc])] = posToStr(current);
            gScore[nr][nc] = tentative_gScore;
            fScore[nr][nc] = tentative_gScore + this.heuristic([nr, nc], goal);
            if (!openSet.some(([r, c]) => r === nr && c === nc)) {
              openSet.push([nr, nc]);
            }
          }
        }
      }
    }
    return [start];
  }

  heuristic(pos, goal) {
    return Math.abs(pos[0] - goal[0]) + Math.abs(pos[1] - goal[1]);
  }

  checkZombieInteractions(zombies, maze) {
    const prevZombieCount = this._prevZombieCount ?? zombies.length;
    const toRemove = new Set();
    const maxZombies = 418;

    for (let i = 0; i < zombies.length; i++) {
        if (toRemove.has(i)) continue;
        for (let j = i + 1; j < zombies.length; j++) {
            if (toRemove.has(j)) continue;

            const z1 = zombies[i];
            const z2 = zombies[j];

            if (z1.pos[0] === z2.pos[0] && z1.pos[1] === z2.pos[1] && z1.type !== z2.type) {
                if (Math.random() < 0.5) { // 50% –Ω–∞ 50% - –∞–±–æ –∑'—è–≤–ª—è—î—Ç—å—Å—è –Ω–æ–≤–∏–π –∑–æ–º–±—ñ, –∞–±–æ –≤–∏–¥–∞–ª—è—î—Ç—å—Å—è –æ–¥–∏–Ω
                    if (zombies.length < maxZombies) {
                        this.spawnZombie();
                    }
                } else { // 50% –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –≤–∏–¥–∞–ª–µ–Ω–Ω—è –æ–¥–Ω–æ–≥–æ –∑ –∑–æ–º–±—ñ
                    const toKillIndex = Math.random() < 0.5 ? i : j;
                    toRemove.add(toKillIndex);
                }
                // Break inner loop to prevent multiple interactions for z1 in one cycle
                break;
            }
        }
    }

    if (toRemove.size > 0) {
        const filteredZombies = zombies.filter((_, index) => !toRemove.has(index));
        zombies.length = 0;
        zombies.push(...filteredZombies);
    }
    
    if (prevZombieCount < 3 && zombies.length >= 3) {
        this.startItemSpawning();
        this.startSafeZoneSpawning();
        this.showEventNotification('‚ö†Ô∏è –ó–±—ñ–ª—å—à–µ–Ω–Ω—è –ø–æ–ø—É–ª—è—Ü—ñ—ó –∑–æ–º–±—ñ! –ü—Ä–µ–¥–º–µ—Ç–∏ —Ç–∞ –∑–æ–Ω–∏ –∑–Ω–æ–≤—É –∑ º—è–≤–ª—è—é—Ç—å—Å—è!');
    }
    this._prevZombieCount = zombies.length;

    this.updateStats();
    if (this.zombies.length === 0 && !this.exitVisible) {
        this.spawnExit();
        this.showEventNotification('üèÜ –í—Å—ñ –∑–æ–º–±—ñ –∑–Ω–∏—â–µ–Ω—ñ! –ó–Ω–∞–π–¥—ñ—Ç—å –≤–∏—Ö—ñ–¥!');
    }
  }

  startZombieTypeChange() {
    if (this.zombieTypeChangeInterval) clearInterval(this.zombieTypeChangeInterval);
    this.zombieTypeChangeInterval = setInterval(() => {
      if (!this.isGameActive || this.isPaused || this.zombies.length <= 1) return;
      const randomZombieIndex = Math.floor(Math.random() * this.zombies.length);
      const zombieToChange = this.zombies[randomZombieIndex];
      const newType = Math.random() < 0.1 ? 'boss' : Math.random() < 0.3 ? 'fast' : 'normal';
      let newMaxHealth;
      switch(newType) {
        case 'boss': newMaxHealth = 5; break;
        case 'fast': newMaxHealth = 3; break;
        default: newMaxHealth = 2; break;
      }
      const percent = zombieToChange.health / zombieToChange.maxHealth;
      zombieToChange.type = newType;
      zombieToChange.maxHealth = newMaxHealth;
      zombieToChange.health = Math.max(1, Math.round(percent * newMaxHealth));
      zombieToChange.speed = newType === 'fast' ? 80 : newType === 'boss' ? 220 : 140;
      this.renderMaze(); this.updateStats();
    }, 10000);
  }

  spawnExit() {
    const corners = [[1, this.size-2], [this.size-2, 1], [this.size-2, this.size-2]];
    this.exitPos = corners[Math.floor(Math.random()*corners.length)];
    this.exitVisible = true;
    this.playerStatusEl.textContent = 'üèÜ –ó–Ω–∞–π–¥—ñ—Ç—å —á–µ—Ä–≤–æ–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç!';
    this.playerStatusEl.style.background = 'rgba(241, 196, 15, 0.8)';
    this.renderMaze(); this.updateStats();
  }

  checkCollision() {
    for (const zombie of this.zombies) {
      if (zombie.pos[0] === this.playerPos[0] && zombie.pos[1] === this.playerPos[1]) {
        const inSafeZone = this.safeZones.some(sz => sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]);
        if (!inSafeZone) {
          if (Date.now() > this.playerBlockedUntil) {
            this.playerBlockedUntil = Date.now() + 3000;
            this.showEventNotification('üèÉ‚Äç‚ôÇÔ∏è –í–∞—Å –∑–Ω–µ—Ä—É—Ö–æ–º–ª–µ–Ω–æ –Ω–∞ 3 —Å–µ–∫—É–Ω–¥–∏!');
          }
          const currentTime = Date.now();
          if (currentTime - this.lastDamageTime > this.damageCooldown) {
            this.lastDamageTime = currentTime;
            if (this.audioZombieBite) { this.audioZombieBite.currentTime = 0; this.audioZombieBite.play(); }
            let damage = zombie.type === 'boss' ? 30 : zombie.type === 'fast' ? 20 : 15;
            if (zombie.inventory && zombie.inventory.hasKnife) {
              damage = Math.round(damage * 1.5); // +50% —É—Ä–æ–Ω—É
            }
            if (this.playerShield > 0) {
              const shieldDamage = Math.min(this.playerShield, damage);
              this.playerShield -= shieldDamage;
              this.playerHealth -= (damage - shieldDamage);
            } else {
              this.playerHealth -= damage;
            }
            this.updateStats();
            this.showEventNotification(`üí• –û—Ç—Ä–∏–º–∞–Ω–æ ${damage} –ø–æ—à–∫–æ–¥–∂–µ–Ω—å${zombie.inventory && zombie.inventory.hasKnife ? ' (–Ω—ñ–∂)' : ''}!`);
            if (this.playerHealth <= 0) { this.endGame(false); return; }
          }
        }
      }
    }
    if (this.exitVisible && this.exitPos && this.playerPos[0] === this.exitPos[0] && this.playerPos[1] === this.exitPos[1]) {
      this.endGame(true);
    }
  }

  startItemSpawning() {
    setTimeout(() => this.spawnAmmo(), 30000 + Math.random() * 15000);
    setTimeout(() => this.spawnHealth(), 40000 + Math.random() * 20000);
    setTimeout(() => this.spawnShield(), 60000 + Math.random() * 30000);
    setTimeout(() => this.spawnPickaxe(), 10000 + Math.random() * 8000);
    setTimeout(() => this.spawnKnife(), 12000 + Math.random() * 10000);
    setTimeout(() => this.spawnMine(), 120000 + Math.random() * 60000);
    setTimeout(() => this.spawnMineDetector(), 45000 + Math.random() * 15000);
  }

  spawnAmmo() { 
    if (this.zombies.length < 3) return; 
    if (this.ammoVisible) return; // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è —Ü–∏–∫–ª—ñ–≤
    this.ammoPos = this.getRandomEmptyPosition(); 
    if (this.ammoPos) { 
      this.ammoVisible = true; 
      this.renderMaze(); 
      this.ammoTimeout = setTimeout(() => this.hideAmmo(), 5000); 
    } 
  }
  hideAmmo() { 
    this.ammoVisible = false; 
    this.ammoPos = null; 
    this.renderMaze(); 
    if (this.ammoTimeout) clearTimeout(this.ammoTimeout);
    setTimeout(() => this.spawnAmmo(), 30000 + Math.random() * 15000); 
  }
  
  spawnHealth() { 
    if (this.zombies.length < 3) return; 
    if (this.healthVisible) return; // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è —Ü–∏–∫–ª—ñ–≤
    this.healthPos = this.getRandomEmptyPosition(); 
    if (this.healthPos) { 
      this.healthVisible = true; 
      this.renderMaze(); 
      this.healthTimeout = setTimeout(() => this.hideHealth(), 5000); 
    } 
  }
  hideHealth() { 
    this.healthVisible = false; 
    this.healthPos = null; 
    this.renderMaze(); 
    if (this.healthTimeout) clearTimeout(this.healthTimeout);
    setTimeout(() => this.spawnHealth(), 40000 + Math.random() * 20000); 
  }
  
  spawnShield() { 
    if (this.zombies.length < 3) return; 
    if (this.shieldVisible) return; // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è —Ü–∏–∫–ª—ñ–≤
    this.shieldPos = this.getRandomEmptyPosition(); 
    if (this.shieldPos) { 
      this.shieldVisible = true; 
      this.renderMaze(); 
      this.shieldTimeout = setTimeout(() => this.hideShield(), 5000); 
    } 
  }
  hideShield() { 
    this.shieldVisible = false; 
    this.shieldPos = null; 
    this.renderMaze(); 
    if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
    setTimeout(() => this.spawnShield(), 60000 + Math.random() * 30000); 
  }
  
  spawnPickaxe() { 
    if (!this.isGameActive) return; 
    if (this.pickaxeVisible) return; // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è —Ü–∏–∫–ª—ñ–≤
    this.pickaxePos = this.getRandomEmptyPosition(); 
    if (!this.pickaxePos) { return; } 
    this.pickaxeVisible = true; 
    this.renderMaze(); 
    const duration = 8000 + Math.random() * 4000; 
    this.pickaxeTimeout = setTimeout(() => { this.hidePickaxe(); }, duration); 
  }
  hidePickaxe() {
    this.pickaxeVisible = false;
    this.pickaxePos = null;
    this.renderMaze();
    if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
    setTimeout(() => this.spawnPickaxe(), 15000 + Math.random() * 10000);
  }
  
  spawnKnife() { 
    if (!this.isGameActive) return; 
    if (this.knifeVisible) return; // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è —Ü–∏–∫–ª—ñ–≤
    this.knifePos = this.getRandomEmptyPosition(); 
    if (!this.knifePos) { return; } 
    this.knifeVisible = true; 
    this.renderMaze(); 
    const duration = 8000 + Math.random() * 4000; 
    this.knifeTimeout = setTimeout(() => { this.hideKnife(); }, duration); 
  }
  hideKnife() { 
    this.knifeVisible = false; 
    this.knifePos = null; 
    this.renderMaze(); 
    if (this.knifeTimeout) clearTimeout(this.knifeTimeout); 
    setTimeout(() => this.spawnKnife(), 20000 + Math.random() * 15000); 
  }
  
  spawnMine() { 
    if (this.mineVisible) return; // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è —Ü–∏–∫–ª—ñ–≤
    this.minePos = this.getRandomEmptyPosition(); 
    if (this.minePos) { 
      this.mineVisible = true; 
      this.renderMaze(); 
      this.mineTimeout = setTimeout(() => this.hideMine(), 6000); 
    } 
  }
  hideMine() { 
    this.mineVisible = false; 
    this.minePos = null; 
    this.renderMaze(); 
    if (this.mineTimeout) clearTimeout(this.mineTimeout); 
    setTimeout(() => this.spawnMine(), 120000 + Math.random() * 60000); 
  }
  
  spawnMineDetector() {
    if (!this.isGameActive) return;
    if (this.mineDetectorVisible) return; // –ó–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–∞–∫–ª–∞–¥–∞–Ω–Ω—è —Ü–∏–∫–ª—ñ–≤
    
    // –ó–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω–∞ –ª–æ–≥—ñ–∫–∞: –¥–µ—Ç–µ–∫—Ç–æ—Ä –∑'—è–≤–ª—è—î—Ç—å—Å—è —Ç—ñ–ª—å–∫–∏ —è–∫—â–æ —î –∞–∫—Ç–∏–≤–Ω—ñ –º—ñ–Ω–∏ –Ω–∞ –∫–∞—Ä—Ç—ñ
    const activeMinesCount = this.activeMines.length;
    if (activeMinesCount === 0) {
      // –Ø–∫—â–æ –Ω–µ–º–∞—î –º—ñ–Ω, –ø–ª–∞–Ω—É—î–º–æ –Ω–∞—Å—Ç—É–ø–Ω—É —Å–ø—Ä–æ–±—É —á–µ—Ä–µ–∑ –¥–æ–≤—à–∏–π —á–∞—Å
      setTimeout(() => this.spawnMineDetector(), 120000 + Math.random() * 60000); // 2-3 —Ö–≤–∏–ª–∏–Ω–∏
      return;
    }
    
    // –Ø–∫—â–æ —î –º—ñ–Ω–∏, –∑'—è–≤–ª—è—î–º–æ—Å—è –∑ –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—é –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –º—ñ–Ω
    const spawnChance = Math.min(0.3 + (activeMinesCount * 0.2), 0.8); // 30-80% —à–∞–Ω—Å
    if (Math.random() > spawnChance) {
      setTimeout(() => this.spawnMineDetector(), 60000 + Math.random() * 30000); // 1-1.5 —Ö–≤–∏–ª–∏–Ω–∏
      return;
    }
    
    this.mineDetectorPos = this.getRandomEmptyPosition();
    if (!this.mineDetectorPos) return;
    this.mineDetectorVisible = true;
    this.renderMaze();
    const duration = 12000 + Math.random() * 8000; // –ó–±—ñ–ª—å—à—É—î–º–æ —á–∞—Å —ñ—Å–Ω—É–≤–∞–Ω–Ω—è
    this.mineDetectorTimeout = setTimeout(() => { this.hideMineDetector(); }, duration);
  }
  hideMineDetector() {
    this.mineDetectorVisible = false;
    this.mineDetectorPos = null;
    this.renderMaze();
    if (this.mineDetectorTimeout) clearTimeout(this.mineDetectorTimeout);
    
    // –ü–ª–∞–Ω—É—î–º–æ –Ω–∞—Å—Ç—É–ø–Ω—É –ø–æ—è–≤—É –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –∞–∫—Ç–∏–≤–Ω–∏—Ö –º—ñ–Ω
    const activeMinesCount = this.activeMines.length;
    let nextSpawnDelay;
    
    if (activeMinesCount === 0) {
      nextSpawnDelay = 180000 + Math.random() * 120000; // 3-5 —Ö–≤–∏–ª–∏–Ω —è–∫—â–æ –Ω–µ–º–∞—î –º—ñ–Ω
    } else if (activeMinesCount <= 2) {
      nextSpawnDelay = 90000 + Math.random() * 60000; // 1.5-2.5 —Ö–≤–∏–ª–∏–Ω–∏
    } else {
      nextSpawnDelay = 60000 + Math.random() * 30000; // 1-1.5 —Ö–≤–∏–ª–∏–Ω–∏
    }
    
    setTimeout(() => this.spawnMineDetector(), nextSpawnDelay);
  }

  tryBreakWall() {
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    for (const [dr,dc] of dirs) {
      const r = this.playerPos[0] + dr;
      const c = this.playerPos[1] + dc;
      if (r >= 0 && r < this.size && c >= 0 && c < this.size && this.maze[r][c] === 1) {
        this.maze[r][c] = 0;
        this.playerHasPickaxe = false;
        if (this.audioBreakWall) { this.audioBreakWall.currentTime = 0; this.audioBreakWall.play(); }
        this.showEventNotification('üß± –°—Ç—ñ–Ω—É –ø—Ä–æ—Ä—É–±–ª–µ–Ω–æ!');
        this.zombies.forEach(zombie => { zombie.path = []; zombie.pathIndex = 0; });
        this.renderMaze();
        // this.spawnPickaxeWithDelay(); // –í–ò–î–ê–õ–ï–ù–û
        break;
      }
    }
  }

  // –í–∏–¥–∞–ª–∏—Ç–∏/–∑–∞–∫–æ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ spawnPickaxeWithDelay —è–∫—â–æ –Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –±—ñ–ª—å—à–µ
  // ... existing code ...
  // –î–ª—è –Ω–æ–∂–∞: –Ω—ñ—á–æ–≥–æ –Ω–µ –≤–∏–∫–ª–∏–∫–∞—Ç–∏ –ø—ñ—Å–ª—è –ø—ñ–¥–±–æ—Ä—É, —Å–ø–∞–≤–Ω –ª–∏—à–µ —á–µ—Ä–µ–∑ hideKnife
  // ... existing code ...

  startSafeZoneSpawning() {
    if (this.zombies.length < 3) return;
    const initialDelay = 3000 + Math.random() * 7000;
    this.safeZoneTimeout = setTimeout(() => { if (!this.isGameActive || this.isPaused) return; this.safeZoneCycle(); }, initialDelay);
  }

  safeZoneCycle() {
    if (this.zombies.length < 3) return;
    const pos = this.getRandomEmptyPosition();
    if (!pos) { // No empty position found
      this.safeZoneTimeout = setTimeout(() => { if (!this.isGameActive || this.isPaused) return; this.safeZoneCycle(); }, 10000);
      return;
    }
    this.safeZones = [pos];
    this.renderMaze();
    this.showEventNotification('üõ°Ô∏è –ó º—è–≤–∏–ª–∞—Å—è –±–µ–∑–ø–µ—á–Ω–∞ –∑–æ–Ω–∞!');
    const zoneDuration = 6000 + Math.random() * 8000;
    this.safeZoneTimeout = setTimeout(() => {
      const expiredZone = this.safeZones.pop();
      this.renderMaze();
      if (expiredZone && this.playerPos[0] === expiredZone[0] && this.playerPos[1] === expiredZone[1]) {
        this.playerStatusEl.textContent = 'üßü‚Äç‚ôÇÔ∏è –í–∏–∂–∏–≤–∞—î...';
        this.playerStatusEl.style.background = 'rgba(52, 152, 219, 0.8)';
        if (this.safeZoneAmmoInterval) { clearInterval(this.safeZoneAmmoInterval); this.safeZoneAmmoInterval = null; }
        if (this.safeZoneShieldInterval) { clearInterval(this.safeZoneShieldInterval); this.safeZoneShieldInterval = null; }
      }
      this.safeZoneTimeout = setTimeout(() => { if (!this.isGameActive || this.isPaused) return; this.safeZoneCycle(); }, 10000);
    }, zoneDuration);
  }

  startTimer() {
    if (this.timerInterval) clearInterval(this.timerInterval);
    this.timerInterval = setInterval(() => {
      if (!this.isPaused && this.isGameActive) {
        this.survivalTime = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(this.survivalTime / 60);
        const seconds = this.survivalTime % 60;
        this.timerEl.textContent = `–ß–∞—Å –≤–∏–∂–∏–≤–∞–Ω–Ω—è: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }, 1000);
  }

  updateStats() {
    document.getElementById('healthDisplay').textContent = this.playerHealth;
    document.getElementById('shieldDisplay').textContent = this.playerShield;
    document.getElementById('ammoDisplay').textContent = this.playerAmmo;
    document.getElementById('zombieCount').textContent = this.zombies.length;
    document.getElementById('levelDisplay').textContent = this.playerLevel;
    
    if (!document.getElementById('pickaxeIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const pickaxeDiv = document.createElement('div');
      pickaxeDiv.className = 'stat-item'; pickaxeDiv.id = 'pickaxeIndicator';
      statsBar.appendChild(pickaxeDiv);
    }
    document.getElementById('pickaxeIndicator').innerHTML = `ü™ì –¢–æ–ø–æ—Ä: <span style="color:${this.playerHasPickaxe ? 'gold' : '#666'}">${this.playerHasPickaxe ? '–Ñ' : '–ù–µ–º–∞—î'}</span>`;
    
    if (!document.getElementById('knifeIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const knifeDiv = document.createElement('div');
      knifeDiv.className = 'stat-item'; knifeDiv.id = 'knifeIndicator';
      statsBar.appendChild(knifeDiv);
    }
    document.getElementById('knifeIndicator').innerHTML = `üî™ –ù—ñ–∂: <span style="color:${this.playerHasKnife ? '#33cc33' : '#666'}">${this.playerHasKnife ? `${6 - this.playerKnifeUses}/6` : '–ù–µ–º–∞—î'}</span>`;
    
    if (!document.getElementById('mineIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const mineDiv = document.createElement('div');
      mineDiv.className = 'stat-item'; mineDiv.id = 'mineIndicator';
      statsBar.appendChild(mineDiv);
    }
    document.getElementById('mineIndicator').innerHTML = `üí£ –ú—ñ–Ω–∏: <span style="color:${this.playerMines > 0 ? '#ff2222' : '#666'}">${this.playerMines}</span>`;
    
    if (!document.getElementById('mineDetectorIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const mineDetectorDiv = document.createElement('div');
      mineDetectorDiv.className = 'stat-item'; mineDetectorDiv.id = 'mineDetectorIndicator';
      statsBar.appendChild(mineDetectorDiv);
    }
    document.getElementById('mineDetectorIndicator').innerHTML = `üß∞ –î–µ—Ç–µ–∫—Ç–æ—Ä –º—ñ–Ω: <span style="color:${this.playerMineDetectorUses > 0 ? '#33cc33' : '#666'}">${this.playerMineDetectorUses > 0 ? this.playerMineDetectorUses : '–ù–µ–º–∞—î'}</span>`;
  }

  updateStatus(status) {
    const statusMap = {
      'ready': { text: '–ì–æ—Ç–æ–≤ –¥–æ –≤–∏–∂–∏–≤–∞–Ω–Ω—è', class: 'status-ready' },
      'playing': { text: '–í–∏–∂–∏–≤–∞—î...', class: 'status-playing' },
      'finished': { text: '–ó–∞–≥–∏–Ω—É–≤!', class: 'status-finished ' }
    };
    const statusInfo = statusMap[status];
    if (statusInfo) {
      this.playerStatusEl.textContent = statusInfo.text;
      this.playerStatusEl.className = `player-status ${statusInfo.class}`;
    }
  }

  togglePause() {
    this.isPaused = !this.isPaused;
    this.pauseBtn.textContent = this.isPaused ? '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏' : '‚è∏Ô∏è –ü–∞—É–∑–∞';
    if (this.isPaused) { this.updateStatus('ready'); this.pauseTime = Date.now(); } 
    else { this.updateStatus('playing'); this.startTime += Date.now() - this.pauseTime; }
  }

  endGame(survived) {
    this.isGameActive = false;
    this.clearAllIntervals();
    if (survived) {
      this.winnerText.textContent = 'üèÜ –ü–ï–†–ï–ú–û–ì–ê!';
      this.winnerMessage.textContent = `–í—ñ—Ç–∞—î–º–æ! –í–∏ –∑–Ω–∏—â–∏–ª–∏ –≤—Å—ñ—Ö –∑–æ–º–±—ñ —Ç–∞ –∑–Ω–∞–π—à–ª–∏ –≤–∏—Ö—ñ–¥!\n–ß–∞—Å –≤–∏–∂–∏–≤–∞–Ω–Ω—è: ${Math.floor(this.survivalTime / 60)}:${(this.survivalTime % 60).toString().padStart(2, '0')}\n–ó–Ω–∏—â–µ–Ω–æ –∑–æ–º–±—ñ: ${this.zombiesKilled}\n–î–æ—Å—è–≥–Ω—É—Ç–∏–π —Ä—ñ–≤–µ–Ω—å: ${this.playerLevel}`;
      if (this.audioWin) { this.audioWin.currentTime = 0; this.audioWin.play(); }
    } else {
      this.winnerText.textContent = 'üíÄ –ó–ê–ì–ò–ù–£–í!';
      this.winnerMessage.textContent = `–í–∏ –Ω–µ –≤–∏–∂–∏–ª–∏ –≤ –∑–æ–º–±—ñ-–∞–ø–æ–∫–∞–ª—ñ–ø—Å–∏—Å—ñ!\n–ß–∞—Å –≤–∏–∂–∏–≤–∞–Ω–Ω—è: ${Math.floor(this.survivalTime / 60)}:${(this.survivalTime % 60).toString().padStart(2, '0')}\n–ó–Ω–∏—â–µ–Ω–æ –∑–æ–º–±—ñ: ${this.zombiesKilled}\n–î–æ—Å—è–≥–Ω—É—Ç–∏–π —Ä—ñ–≤–µ–Ω—å: ${this.playerLevel}`;
      if (this.audioPlayerDeath) { this.audioPlayerDeath.currentTime = 0; this.audioPlayerDeath.play(); }
      if (this.audioLose) { this.audioLose.currentTime = 0; this.audioLose.play(); }
    }
    this.winnerOverlay.style.display = 'flex';
    this.pauseBtn.disabled = true;
  }

  showEventNotification(message) {
    const existingNotification = document.querySelector('.event-notification');
    if (existingNotification) existingNotification.remove();
    const notification = document.createElement('div');
    notification.className = 'event-notification';
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      if (notification.parentNode) {
        notification.style.animation = 'fadeOut 0.5s ease-out';
        setTimeout(() => { if (notification.parentNode) notification.remove(); }, 500);
      }
    }, 3000);
  }

  startRandomMazeEvents() { this.scheduleNextRandomEvent(); }

  scheduleNextRandomEvent() {
    if (!this.isGameActive || this.isPaused) return;
    const delay = 1000 + Math.random() * 119000;
    this.eventInterval = setTimeout(() => {
        if (!this.isGameActive || this.isPaused) return;
        this.randomMazeEvent();
        this.scheduleNextRandomEvent();
    }, delay);
  }

  randomMazeEvent() {
    const isAdd = Math.random() < 0.5;
    const size = this.size;
    const forbiddenSet = new Set();
    forbiddenSet.add(this.playerPos[0] + ',' + this.playerPos[1]);
    this.zombies.forEach(z => forbiddenSet.add(z.pos[0] + ',' + z.pos[1]));
    if (this.exitVisible && this.exitPos) forbiddenSet.add(this.exitPos[0] + ',' + this.exitPos[1]);
    if (this.ammoVisible && this.ammoPos) forbiddenSet.add(this.ammoPos[0] + ',' + this.ammoPos[1]);
    if (this.healthVisible && this.healthPos) forbiddenSet.add(this.healthPos[0] + ',' + this.healthPos[1]);
    if (this.shieldVisible && this.shieldPos) forbiddenSet.add(this.shieldPos[0] + ',' + this.shieldPos[1]);
    if (this.pickaxeVisible && this.pickaxePos) forbiddenSet.add(this.pickaxePos[0] + ',' + this.pickaxePos[1]);
    if (this.knifeVisible && this.knifePos) forbiddenSet.add(this.knifePos[0] + ',' + this.knifePos[1]);
    this.safeZones.forEach(sz => forbiddenSet.add(sz[0] + ',' + sz[1]));
    forbiddenSet.add('1,1');

    let wallChanged = false;
    for (let attempt = 0; attempt < 100; attempt++) {
        const row = Math.floor(Math.random() * (size - 2)) + 1;
        const col = Math.floor(Math.random() * (size - 2)) + 1;
        const key = row + ',' + col;
        if (forbiddenSet.has(key)) continue;
        if (isAdd && this.maze[row][col] === 0) {
            this.maze[row][col] = 1; this.showEventNotification('üß± –ó\'—è–≤–∏–ª–∞—Å—è –Ω–æ–≤–∞ —Å—Ç—ñ–Ω–∞!'); wallChanged = true; break;
        } else if (!isAdd && this.maze[row][col] === 1) {
            this.maze[row][col] = 0; this.showEventNotification('üï≥Ô∏è –°—Ç—ñ–Ω–∞ –∑–Ω–∏–∫–ª–∞!'); wallChanged = true; break;
        }
    }
    if (wallChanged) {
        this.zombies.forEach(zombie => { zombie.path = []; zombie.pathIndex = 0; });
        this.renderMaze();
    }
  }

  checkMinesExplosion() {
    for (let i = this.activeMines.length - 1; i >= 0; i--) {
        const mine = this.activeMines[i];
        // –ú—ñ–Ω–∏ –≥—Ä–∞–≤—Ü—è —à–∫–æ–¥—è—Ç—å —Ç—ñ–ª—å–∫–∏ –∑–æ–º–±—ñ
        if (mine.placedBy === 'player') {
            const zombieIndex = this.zombies.findIndex(z => z.pos[0] === mine.pos[0] && z.pos[1] === mine.pos[1]);
            if (zombieIndex !== -1) {
                const zombie = this.zombies[zombieIndex];
                const mineDamage = Math.floor(Math.random() * 5) + 1;
                zombie.health -= mineDamage;
                zombie.stunnedUntil = Date.now() + 1000;
                if (zombie.health <= 0) {
                    this.zombies.splice(zombieIndex, 1);
                    this.zombiesKilled++;
                } else {
                    // –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –ø–æ—Ä–∞–Ω–µ–Ω–Ω—è –∑–æ–º–±—ñ –º—ñ–Ω–æ—é –ø—Ä–∏–±—Ä–∞–Ω–æ
                }
                if (this.audioMineExplosion) { this.audioMineExplosion.currentTime = 0; this.audioMineExplosion.play(); }
                this.activeMines.splice(i, 1);
                this.renderMaze();
                this.updateStats();
                if (this.zombies.length === 0 && !this.exitVisible) {
                    this.spawnExit();
                    this.showEventNotification('üèÜ –í—Å—ñ –∑–æ–º–±—ñ –∑–Ω–∏—â–µ–Ω—ñ! –ó–Ω–∞–π–¥—ñ—Ç—å –≤–∏—Ö—ñ–¥!');
                }
            }
        }
    }
  }
  
  tryPlaceMine() {
    if (this.playerMines > 0) {
      const [row, col] = this.playerPos;
      const isInSafeZone = this.safeZones.some(sz => sz[0] === row && sz[1] === col);
      const isStart = row === 1 && col === 1;
      const isZombieOnPlayer = this.zombies.some(z => z.pos[0] === row && z.pos[1] === col);
      if (this.maze[row][col] === 0 && !this.activeMines.some(m => m.pos[0] === row && m.pos[1] === col) && !isInSafeZone && !isStart && !isZombieOnPlayer) {
        this.activeMines.push({pos: [row, col], placedAt: Date.now(), placedBy: 'player'});
        this.playerMines--;
        this.updateStats();
        if (this.audioMinePlace) { this.audioMinePlace.currentTime = 0; this.audioMinePlace.play(); }
        this.renderMaze();
      } else if (isZombieOnPlayer) {
        this.showEventNotification('‚ùå –ù–µ –º–æ–∂–Ω–∞ —Å—Ç–∞–≤–∏—Ç–∏ –º—ñ–Ω—É, –∫–æ–ª–∏ –Ω–∞ –∫–ª—ñ—Ç–∏–Ω—Ü—ñ —î –∑–æ–º–±—ñ!');
      } else {
        this.showEventNotification('‚ùå –ù–µ–º–æ–∂–ª–∏–≤–æ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ –º—ñ–Ω—É —Ç—É—Ç!');
      }
    } else {
      this.showEventNotification('‚ùå –£ –≤–∞—Å –Ω–µ–º–∞—î –º—ñ–Ω!');
    }
  }

  tryPlaceZombieMine(zombie) {
    if (zombie.inventory.mines > 0) {
        const [row, col] = zombie.pos;
        const canPlace = this.maze[row][col] === 0 &&
            !this.activeMines.some(m => m.pos[0] === row && m.pos[1] === col) &&
            !(this.playerPos[0] === row && this.playerPos[1] === col) &&
            !this.safeZones.some(sz => sz[0] === row && sz[1] === col);

        if (canPlace) {
            this.activeMines.push({ pos: [row, col], placedAt: Date.now(), placedBy: 'zombie' });
            zombie.inventory.mines--;
            this.showEventNotification('üí£ –ó–æ–º–±—ñ –≤—Å—Ç–∞–Ω–æ–≤–∏–≤ –º—ñ–Ω—É!');
            if (this.audioMinePlace) { this.audioMinePlace.currentTime = 0; this.audioMinePlace.play(); }
            this.renderMaze();
        }
    }
  }

  checkPlayerMineExplosion() {
    for (let i = this.activeMines.length - 1; i >= 0; i--) {
      const mine = this.activeMines[i];
      if (this.playerPos[0] === mine.pos[0] && this.playerPos[1] === mine.pos[1]) {
        // –ì—Ä–∞–≤–µ—Ü—å –ø—ñ–¥—Ä–∏–≤–∞—î—Ç—å—Å—è –Ω–∞ –±—É–¥—å-—è–∫—ñ–π –º—ñ–Ω—ñ, —è–∫—â–æ –ø—Ä–æ–π—à–ª–æ –±—ñ–ª—å—à–µ 0.5 —Å–µ–∫ –∑ –º–æ–º–µ–Ω—Ç—É –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è
        if (Date.now() - mine.placedAt < 500) continue;
        
        this.activeMines.splice(i, 1);
        const damage = mine.placedBy === 'zombie' ? 50 : Math.floor(Math.random() * 200) + 1; // –ú—ñ–Ω–∏ –∑–æ–º–±—ñ –º–µ–Ω—à –ø–æ—Ç—É–∂–Ω—ñ
        if (this.playerShield > 0) {
          const shieldDamage = Math.min(this.playerShield, damage);
          this.playerShield -= shieldDamage;
          this.playerHealth -= (damage - shieldDamage);
        } else {
          this.playerHealth -= damage;
        }
        this.playerBlockedUntil = Date.now() + 3000;
        this.updateStats();
        this.showEventNotification(`üí• –í–∏ –ø—ñ–¥—ñ—Ä–≤–∞–ª–∏—Å—è –Ω–∞ –º—ñ–Ω—ñ! -${damage} HP`);
        if (this.audioMineExplosion) { this.audioMineExplosion.currentTime = 0; this.audioMineExplosion.play(); }
        this.renderMaze();
        if (this.playerHealth <= 0) {
          this.endGame(false);
        }
      }
    }
  }

  tryDefuseMine() {
    if (this.playerMineDetectorUses <= 0) {
      this.showEventNotification('‚ùå –£ –≤–∞—Å –Ω–µ–º–∞—î –º—ñ–Ω–Ω–æ–≥–æ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞!');
      return;
    }
    // –ú–æ–∂–Ω–∞ —Ä–æ–∑–º—ñ–Ω—É–≤–∞—Ç–∏ –º—ñ–Ω—É –∑–æ–º–±—ñ –∞–±–æ —Å–≤–æ—é –º—ñ–Ω—É –Ω–∞ —Å—É—Å—ñ–¥–Ω—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    let defused = false;
    let defusedMineType = '';
    
    for (const [dr,dc] of dirs) {
      const r = this.playerPos[0] + dr;
      const c = this.playerPos[1] + dc;
      const mineIdx = this.activeMines.findIndex(m => m.pos[0] === r && m.pos[1] === c);
      
      if (mineIdx !== -1) {
        const mine = this.activeMines[mineIdx];
        this.activeMines.splice(mineIdx, 1);
        this.playerMineDetectorUses--;
        
        if (mine.placedBy === 'zombie') {
          this.showEventNotification('üß∞ –í–∏ —Ä–æ–∑–º—ñ–Ω—É–≤–∞–ª–∏ –º—ñ–Ω—É –∑–æ–º–±—ñ!');
        } else {
          this.showEventNotification('üß∞ –í–∏ —Ä–æ–∑–º—ñ–Ω—É–≤–∞–ª–∏ —Å–≤–æ—é –º—ñ–Ω—É!');
        }
        
        this.renderMaze();
        this.updateStats();
        defused = true;
        break;
      }
    }
    
    if (!defused) {
      this.showEventNotification('‚ùå –ü–æ—Ä—É—á –Ω–µ–º–∞—î –º—ñ–Ω –¥–ª—è —Ä–æ–∑–º—ñ–Ω—É–≤–∞–Ω–Ω—è!');
    }
    
    if (this.audioMineDefuse) { this.audioMineDefuse.currentTime = 0; this.audioMineDefuse.play(); }
  }
}

// –ó–∞–ø—É—Å–∫ –≥—Ä–∏
window.addEventListener('DOMContentLoaded', () => {
  window.zombieGame = new ZombieApocalypseGame();
});
</script>

<nav class="menu-nav">
  <a href="index.html" class="menu-btn">–ì–æ–ª–æ–≤–Ω–∞</a>
  <a href="global.html" class="menu-btn">GLOBAL</a>
  <a href="test-mode.html" class="menu-btn">test-mode</a>
  <a href="test-mode-experimental.html" class="menu-btn">test-mode-experimental</a>
  <a href="npc-ai.html" class="menu-btn">npc-ai</a>
  <a href="npc-ai-mini.html" class="menu-btn">npc-ai-mini</a>
  <a href="standings.html" class="menu-btn">–¢—É—Ä–Ω—ñ—Ä–Ω–∞ —Ç–∞–±–ª–∏—Ü—è</a>
</nav>

<div class="instructions">
  <h3>üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ-–ê–ø–æ–∫–∞–ª—ñ–ø—Å–∏—Å: –õ–∞–±—ñ—Ä–∏–Ω—Ç –í–∏–∂–∏–≤–∞–Ω–Ω—è</h3>
  <p><strong>üéØ –¶—ñ–ª—å:</strong> –ó–Ω–∏—â–∏—Ç–∏ –≤—Å—ñ—Ö –∑–æ–º–±—ñ, —â–æ–± –∑'—è–≤–∏–≤—Å—è —á–µ—Ä–≤–æ–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç (–≤–∏—Ö—ñ–¥), –ø–æ—Ç—ñ–º –¥—ñ—Å—Ç–∞—Ç–∏—Å—è –¥–æ –Ω—å–æ–≥–æ!</p>
  <p><strong>üéÆ –ö–µ—Ä—É–≤–∞–Ω–Ω—è:</strong> –°—Ç—Ä—ñ–ª–∫–∏ ‚Üê‚Üë‚Üì‚Üí –∞–±–æ WASD –¥–ª—è —Ä—É—Ö—É, –ü—Ä–æ–±—ñ–ª –¥–ª—è –∞—Ç–∞–∫–∏ (—Ç—ñ–ª—å–∫–∏ –∫–æ–ª–∏ —Å—Ç–æ—ó—Ç–µ), E –¥–ª—è —Ç–æ–ø–æ—Ä–∞, X –¥–ª—è –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –º—ñ–Ω–∏, R –¥–ª—è —Ä–æ–∑–º—ñ–Ω—É–≤–∞–Ω–Ω—è –º—ñ–Ω–∏</p>
  <p><strong>üìã –ü—Ä–∞–≤–∏–ª–∞:</strong> –ó–µ–ª–µ–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç - —Å—Ç–∞—Ä—Ç. –ó–æ–º–±—ñ —Ä—É—Ö–∞—é—Ç—å—Å—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é A* –∞–ª–≥–æ—Ä–∏—Ç–º—É. –ó–±–∏—Ä–∞–π—Ç–µ –ø–∞—Ç—Ä–æ–Ω–∏, –∑–¥–æ—Ä–æ–≤'—è, —â–∏—Ç–∏, —Ç–æ–ø–æ—Ä–∏ —Ç–∞ –Ω–æ–∂—ñ. –ë–µ–∑–ø–µ—á–Ω—ñ –∑–æ–Ω–∏ —Ç–∏–º—á–∞—Å–æ–≤–æ –∑–∞—Ö–∏—â–∞—é—Ç—å –≤—ñ–¥ –∑–æ–º–±—ñ!</p>
  <p><strong>üßü‚Äç‚ôÇÔ∏è –ó–æ–º–±—ñ:</strong> –ó'—è–≤–ª—è—é—Ç—å—Å—è –¢–Ü–õ–¨–ö–ò –ø—Ä–∏ –∫–æ–Ω—Ç–∞–∫—Ç—ñ —Ä—ñ–∑–Ω–∏—Ö —Ç–∏–ø—ñ–≤. –¢–∏–ø–∏ –∑–º—ñ–Ω—é—é—Ç—å—Å—è –∫–æ–∂–Ω—ñ 10 —Å–µ–∫—É–Ω–¥. <strong>–£–í–ê–ì–ê:</strong> –ó–æ–º–±—ñ —Ç–µ–ø–µ—Ä –º–æ–∂—É—Ç—å –ø—ñ–¥–±–∏—Ä–∞—Ç–∏ –ø—Ä–µ–¥–º–µ—Ç–∏, —Å—Ç—Ä—ñ–ª—è—Ç–∏, —Å—Ç–∞–≤–∏—Ç–∏ –º—ñ–Ω–∏ —Ç–∞ —Ä—É–π–Ω—É–≤–∞—Ç–∏ —Å—Ç—ñ–Ω–∏!</p>
  <p><strong>üí™ –ó–¥–æ—Ä–æ–≤'—è –∑–æ–º–±—ñ:</strong> –ó–≤–∏—á–∞–π–Ω–∏–π (2 HP), –®–≤–∏–¥–∫–∏–π (3 HP), –ë–æ—Å (5 HP)</p>
  <p><strong>ü™ì –¢–æ–ø–æ—Ä:</strong> –î–æ–∑–≤–æ–ª—è—î –ø—Ä–æ—Ä—É–±—É–≤–∞—Ç–∏ —Å—Ç—ñ–Ω–∏ –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–∏—Ö —à–ª—è—Ö—ñ–≤!</p>
  <p><strong>üî™ –ù—ñ–∂:</strong> –ü–æ—Ç—Ä—ñ–±–µ–Ω –¥–ª—è –±–ª–∏–∂–Ω—å–æ–≥–æ –±–æ—é! –ë–µ–∑ –Ω–æ–∂–∞ –Ω–µ–º–æ–∂–ª–∏–≤–æ –∞—Ç–∞–∫—É–≤–∞—Ç–∏ –∑–æ–º–±—ñ –Ω–∞ —Ç—ñ–π —Å–∞–º—ñ–π –∫–ª—ñ—Ç–∏–Ω—Ü—ñ.</p>
  <p><strong>üî´ –ë–æ–π–æ–≤–∞ —Å–∏—Å—Ç–µ–º–∞:</strong> –ë–ª–∏–∂–Ω—ñ–π –±—ñ–π –Ω–æ–∂–µ–º (–Ω–µ –≤–∏—Ç—Ä–∞—á–∞—î –ø–∞—Ç—Ä–æ–Ω–∏) –∞–±–æ —Å—Ç—Ä—ñ–ª—å–±–∞ (–≤–∏—Ç—Ä–∞—á–∞—î –ø–∞—Ç—Ä–æ–Ω–∏). –ë–µ–∑ –Ω–æ–∂–∞ - –Ω–µ–º–æ–∂–ª–∏–≤–æ –∞—Ç–∞–∫—É–≤–∞—Ç–∏ –≤ –±–ª–∏–∂–Ω—å–æ–º—É –±–æ—é!</p>
  <p><strong>üèÜ –ü–µ—Ä–µ–º–æ–≥–∞:</strong> –°–ø–æ—á–∞—Ç–∫—É –∑–Ω–∏—â—ñ—Ç—å –í–°–Ü–• –∑–æ–º–±—ñ ‚Üí –∑'—è–≤–∏—Ç—å—Å—è —á–µ—Ä–≤–æ–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç —É –≤–∏–ø–∞–¥–∫–æ–≤–æ–º—É –∫—É—Ç—ñ ‚Üí –¥—ñ—Å—Ç–∞–Ω—å—Ç–µ—Å—è –¥–æ –Ω—å–æ–≥–æ!</p>
  <p><strong>üéÆ –†—ñ–≤–Ω—ñ —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ:</strong> –õ–µ–≥–∫–∏–π, –°–µ—Ä–µ–¥–Ω—ñ–π, –í–∞–∂–∫–∏–π, –ö–æ—à–º–∞—Ä</p>
</div>
</body>
</html>