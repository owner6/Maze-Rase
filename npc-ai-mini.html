<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Зомбі-Апокаліпсис: Лабіринт Виживання</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 50vh;
      padding: 10px;
    }

    .header {
      text-align: center;
      margin-bottom: 0px;
    }

    .header h1 {
      font-size: 1em;
      margin-bottom: 5px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      color: #e74c3c;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 5px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 12px 24px;
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      border: none;
      border-radius: 25px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }

    .btn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(255,255,255,0.05);
      border-radius: 20px;
      padding: 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.1);
      max-width: 1400px;
      width: 100%;
    }

    .player-info {
      margin-bottom: 15px;
      text-align: center;
      display: flex;
      gap: 3px;
      align-items: center;
    }

    .player-name {
      font-size: 1em;
      font-weight: bold;
      margin-bottom: 5px;
      color: #3498db;
    }

    .player-status {
      font-size: 1em;
      padding: 5px 10px;
      border-radius: 15px;
      display: inline-block;
    }

    .status-ready { background: rgba(52, 152, 219, 0.8); }
    .status-playing { background: rgba(46, 204, 113, 0.8); }
    .status-finished { background: rgba(231, 76, 60, 0.8); }
    .status-winner { background: rgba(241, 196, 15, 0.8); }

    .maze-container {
      border: 3px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      margin-bottom: 20px;
    }

    .maze {
      display: grid;
      background: #2c3e50;
    }

    .cell {
      width: 24px;
      height: 24px;
      border: 0.5px solid rgba(52, 73, 94, 0.5);
    }

    .wall { background: #34495e; }
    .path { background: #ecf0f1; }
    .start { background: #27ae60; }
    .end { background: #e74c3c; }
    .player { background: #3498db; box-shadow: 0 0 10px #3498db; }
    .zombie { 
      background: #8B4513; 
      box-shadow: 0 0 8px #8B4513;
      border-radius: 50%;
    }
    .zombie-fast { 
      background: #FF4500; 
      box-shadow: 0 0 8px #FF4500;
      border-radius: 50%;
    }
    .zombie-boss { 
      background: #1a0033;
      border-radius: 10px;
      border: 3px solid #ff2222;
      box-shadow: 0 0 16px 4px #ff2222, 0 0 8px 2px #fff;
      position: relative;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .ammo-cell {
      background: #FFD700;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #FFA500;
      z-index: 2;
    }
    .health-cell {
      background: #FF69B4;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #FF1493;
      z-index: 2;
    }
    .shield-cell {
      background: #00CED1;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #008B8B;
      z-index: 2;
    }
    .safe-zone {
      background: #32CD32;
      border: 2px solid #228B22;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }

    .timer {
      font-size: 1.1em;
      margin: 0;
      padding: 5px 15px;
      background: rgba(0,0,0,0.5);
      border-radius: 15px;
      display: inline-block;
    }

    .stats-bar {
      display: flex;
      gap: 20px;
      margin: 5px 5;
      flex-wrap: wrap;
      justify-content: center;
    }

    .stat-item {
      background: rgba(0,0,0,0.3);
      padding: 8px 15px;
      border-radius: 10px;
      font-size: 14px;
    }

    .instructions {
      margin-top: 20px;
      text-align: center;
      max-width: 600px;
      background: rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .winner-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .winner-modal {
      background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.7);
      animation: modalAppear 0.5s ease-out;
    }

    @keyframes modalAppear {
      from { transform: scale(0.5); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .winner-text {
      font-size: 3em;
      margin-bottom: 20px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }

    .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 10px 0;
    }

    .size-controls label {
      font-weight: bold;
    }

    .size-controls select {
      padding: 8px;
      border-radius: 8px;
      border: none;
      background: rgba(255,255,255,0.2);
      color: white;
      font-size: 14px;
    }

    .event-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.5);
      z-index: 1000;
      animation: slideInRight 0.5s ease-out;
      max-width: 300px;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    @media (max-width: 768px) {
      .cell {
        width: 13px;
        height: 13px;
      }

      .header h1 {
        font-size: 2em;
      }
    }

    .pickaxe-cell {
      background: gold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #bfa100;
      z-index: 2;
    }

    .knife-cell {
      background: #8B0000;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #660000;
      z-index: 2;
    }

    .stake-cell {
      background: #FFD700;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #FFA500;
      z-index: 2;
    }

    .mine-cell {
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #444;
      border-radius: 50%;
      position: relative;
      z-index: 2;
    }
    .mine-cell::after {
      content: '';
      width: 6px;
      height: 6px;
      background: #ff2222;
      border-radius: 50%;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    .mine-cell.mine-item {
      background: #ffe066 !important;
      border: 2px solid #ffd700 !important;
    }
    /* Mine placed by zombie */
    .zombie-mine-cell {
      border: 2px solid #8A2BE2 !important; /* Violet border */
    }

    .menu-nav {
      display: flex;
      gap: 14px;
      justify-content: center;
      margin-bottom: 18px;
    }
    .menu-btn {
      display: inline-block;
      padding: 12px 28px;
      background: linear-gradient(45deg, #e74c3c, #c0392b);
      border: none;
      border-radius: 25px;
      color: white;
      font-size: 17px;
      font-weight: bold;
      text-decoration: none;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transition: all 0.2s;
      cursor: pointer;
      outline: none;
    }
    .menu-btn:hover, .menu-btn.active {
      background: linear-gradient(45deg, #c0392b, #e74c3c);
      color: #fffbe6;
      transform: translateY(-2px) scale(1.04);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      text-shadow: 0 1px 4px #0008;
    }

    .mine-detector-cell {
      background: #b0e0e6;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #4682b4;
      z-index: 2;
    }
  </style>
</head>
<body>
<audio id="audioStart" src="sounds/start.wav"></audio>
<audio id="audioKnife" src="sounds/knife.wav"></audio>
<audio id="audioGun" src="sounds/gun.wav"></audio>
<audio id="audioStep" src="sounds/step.wav"></audio>
<audio id="audioZombie" src="sounds/zombie.wav"></audio>
<audio id="audioPickup" src="sounds/pickup.wav"></audio>
<audio id="audioWin" src="sounds/win.wav"></audio>
<audio id="audioLose" src="sounds/lose.mp3"></audio>
<audio id="audioMineExplosion" src="sounds/mine-explosion.flac"></audio>
<audio id="audioMinePlace" src="sounds/mine-place.flac"></audio>
<audio id="audioZombieHit" src="sounds/zombie-hit.wav"></audio>
<audio id="audioZombieKill" src="sounds/zombie-kill.wav"></audio>
<audio id="audioZombieSee" src="sounds/zombie-see.ogg"></audio>
<audio id="audioSafeZone" src="sounds/safe-zone.wav"></audio>
<audio id="audioZombieBite" src="sounds/zombie-bite.wav"></audio>
<audio id="audioBreakWall" src="sounds/break-wall.mp3"></audio>
<audio id="audioPlayerDeath" src="sounds/player-death.mp3"></audio>
<audio id="audioMineDefuse" src="sounds/pickup-of.wav"></audio>

<div class="header">
  <h1>🧟‍♂️ Зомбі-Апокаліпсис: Лабіринт Виживання</h1>
</div>

<div class="controls">
  <div class="size-controls">
    <label>Рівень складності:</label>
    <select id="difficultyLevel">
      <option value="easy" selected>Легкий</option>
      <option value="medium">Середній</option>
      <option value="hard">Важкий</option>
      <option value="nightmare">Кошмар</option>
    </select>
  </div>
  <button class="btn" id="newGameBtn">🧟‍♂️ Нова гра</button>
  <button class="btn" id="pauseBtn" disabled>⏸️ Пауза</button>
  <button class="btn" id="helpBtn">❓ Допомога</button>
</div>

<div class="game-container">
  <div class="player-info">
    <div>
      <div class="player-name">🎯 ГРАВЕЦЬ</div>
      <div class="player-status status-ready" id="playerStatus">Готов до виживання</div>
    </div>
    <div class="timer" id="timer">Час виживання: 00:00</div>
  </div>
  
  <div class="stats-bar" id="statsBar">
    <div class="stat-item">❤️ Здоров'я: <span id="healthDisplay">100</span></div>
    <div class="stat-item">🛡️ Щит: <span id="shieldDisplay">0</span></div>
    <div class="stat-item">🔫 Патрони: <span id="ammoDisplay">10</span></div>
    <div class="stat-item">🧟‍♂️ Зомбі: <span id="zombieCount">0</span></div>
    <div class="stat-item">🏆 Рівень: <span id="levelDisplay">1</span></div>
  </div>

  <div class="maze-container">
    <div class="maze" id="maze"></div>
  </div>
</div>

<div class="winner-overlay" id="winnerOverlay">
  <div class="winner-modal">
    <div class="winner-text" id="winnerText">🏆 ВИЖИВ!</div>
    <p id="winnerMessage">Вітаємо з виживанням!</p>
    <button class="btn" id="playAgainBtn">🔄 Грати знову</button>
  </div>
</div>

<script>
class MazeGenerator {
  constructor(size) {
    this.size = size;
    this.maze = [];
    this.generate();
  }

  generate() {
    this.maze = Array(this.size).fill().map(() => Array(this.size).fill(1));
    const stack = [];
    const start = [1, 1];
    this.maze[start[0]][start[1]] = 0;
    stack.push(start);

    while (stack.length > 0) {
      const current = stack[stack.length - 1];
      const neighbors = this.getUnvisitedNeighbors(current);

      if (neighbors.length > 0) {
        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
        this.removeWall(current, next);
        this.maze[next[0]][next[1]] = 0;
        stack.push(next);
      } else {
        stack.pop();
      }
    }

    this.maze[this.size - 2][this.size - 2] = 0;
  }

  getUnvisitedNeighbors([row, col]) {
    const neighbors = [];
    const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];

    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;

      if (newRow > 0 && newRow < this.size - 1 &&
        newCol > 0 && newCol < this.size - 1 &&
        this.maze[newRow][newCol] === 1) {
        neighbors.push([newRow, newCol]);
      }
    }

    return neighbors;
  }

  removeWall([row1, col1], [row2, col2]) {
    const wallRow = (row1 + row2) / 2;
    const wallCol = (col1 + col2) / 2;
    this.maze[wallRow][wallCol] = 0;
  }
}

class ZombieApocalypseGame {
  constructor() {
    this.size = 29;
    this.maze = null;
    this.playerPos = [1, 1];
    this.isGameActive = false;
    this.isPaused = false;
    this.startTime = null;
    this.timerInterval = null;
    this.playerDirection = null;
    this.playerMoveInterval = null;
    this.zombies = [];
    this.zombieMoveInterval = null;
    this.eventInterval = null;
    this.itemSpawnInterval = null;
    this.zombieTypeChangeInterval = null;
    this.collisionCheckInterval = null;
    this.playerBlockedUntil = 0;
    
    // Статистика гравця
    this.playerHealth = 100;
    this.playerShield = 0;
    this.playerAmmo = 10;
    this.playerLevel = 1;
    this.zombiesKilled = 0;
    this.survivalTime = 0;
    
    // Предмети
    this.ammoPos = null;
    this.ammoVisible = false;
    this.healthPos = null;
    this.healthVisible = false;
    this.shieldPos = null;
    this.shieldVisible = false;
    this.pickaxePos = null;
    this.pickaxeVisible = false;
    this.playerHasPickaxe = false;
    this.knifePos = null;
    this.knifeVisible = false;
    this.playerHasKnife = true; // Ніж одразу у гравця
    this.playerKnifeUses = 0;   // 6 ударів доступно
    this.minePos = null;
    this.mineVisible = false;
    this.playerMines = 0;
    this.mineTimeout = null;
    this.activeMines = [];
    
    // Таймери для предметів
    this.ammoTimeout = null;
    this.healthTimeout = null;
    this.shieldTimeout = null;
    this.pickaxeTimeout = null;
    this.knifeTimeout = null;
    
    // Захист від спаму повідомлень
    this.lastDamageTime = 0;
    this.damageCooldown = 1000; // 1 секунда між повідомленнями про пошкодження
    
    // Безпечні зони
    this.safeZones = [];
    this.safeZoneTimeout = null;
    
    // Вихід (з'являється після вбивства всіх зомбі)
    this.exitPos = null;
    this.exitVisible = false;
    
    // Налаштування складності
    this.difficulty = 'easy';
    this.zombieSpawnRate = 5000;
    this.itemSpawnRate = 8000;
    this.safeZoneRate = 15000;
    
    // Система відстеження натиснутих клавіш руху
    this.pressedKeys = new Set();
    
    this.initializeElements();
    this.setupEventListeners();
    
    // Додаю аудіо-елементи
    this.audioStart = document.getElementById('audioStart');
    this.audioKnife = document.getElementById('audioKnife');
    this.audioGun = document.getElementById('audioGun');
    this.audioStep = document.getElementById('audioStep');
    this.audioZombie = document.getElementById('audioZombie');
    this.audioPickup = document.getElementById('audioPickup');
    this.audioWin = document.getElementById('audioWin');
    this.audioLose = document.getElementById('audioLose');
    this.audioMineExplosion = document.getElementById('audioMineExplosion');
    this.audioMinePlace = document.getElementById('audioMinePlace');
    this.audioZombieHit = document.getElementById('audioZombieHit');
    this.audioZombieKill = document.getElementById('audioZombieKill');
    this.audioZombieSee = document.getElementById('audioZombieSee');
    this.audioSafeZone = document.getElementById('audioSafeZone');
    this.audioZombieBite = document.getElementById('audioZombieBite');
    this.audioBreakWall = document.getElementById('audioBreakWall');
    this.audioPlayerDeath = document.getElementById('audioPlayerDeath');
    this.audioMineDefuse = document.getElementById('audioMineDefuse');
    this.wasInSafeZone = false;
    
    this.zombieLastSeenState = new Map(); // Для контролю звуку появи у полі зору
    this.mineDetectorPos = null;
    this.mineDetectorVisible = false;
    this.playerMineDetectorUses = 0;
    this.mineDetectorTimeout = null;
  }

  initializeElements() {
    this.mazeEl = document.getElementById('maze');
    this.playerStatusEl = document.getElementById('playerStatus');
    this.timerEl = document.getElementById('timer');
    this.winnerOverlay = document.getElementById('winnerOverlay');
    this.winnerText = document.getElementById('winnerText');
    this.winnerMessage = document.getElementById('winnerMessage');
    this.newGameBtn = document.getElementById('newGameBtn');
    this.pauseBtn = document.getElementById('pauseBtn');
    this.playAgainBtn = document.getElementById('playAgainBtn');
    this.difficultySelect = document.getElementById('difficultyLevel');
  }

  setupEventListeners() {
    this.newGameBtn.addEventListener('click', () => this.newGame());
    this.pauseBtn.addEventListener('click', () => this.togglePause());
    this.playAgainBtn.addEventListener('click', () => this.newGame());

    document.getElementById('helpBtn').addEventListener('click', () => {
      alert('🧟‍♂️ ЗОМБІ-АПОКАЛІПСИС: ЛАБІРИНТ ВИЖИВАННЯ\n\n🎯 Ціль: Знищити всіх зомбі, щоб з\'явився червоний квадрат (вихід), потім дістатися до нього!\n\n🎮 Керування:\n• Стрілки ←↑↓→ або WASD для руху\n• Пробіл для атаки (тільки коли стоїте)\n• E для використання топора (якщо є)\n\n⚔️ Бойова система:\n• Ближній бій (зомбі на вашій клітинці): Потрібен ніж, патрони не витрачаються.\n• Стрільба (зомбі на відстані): Потрібні патрони, ніж не потрібен.\n• Без ножа неможливо атакувати в ближньому бою!\n• Без патронів неможливо стріляти!\n\n📋 Інше:\n• Зелений квадрат - старт\n• Зомбі рухаються за допомогою A* алгоритму\n• Збирайте патрони, здоров\'я, щити та топори\n• Топор дозволяє прорубувати стіни (кнопка E)\n• Безпечні зони тимчасово захищають від зомбі\n• Зомбі з\'являються ТІЛЬКИ при контакті різних типів\n• Типи зомбі змінюються кожні 10 секунд\n• Здоров\'я зомбі: Звичайний(2), Швидкий(3), Бос(5)');
    });

    // Обробники для відстеження натиснутих клавіш руху
    document.addEventListener('keydown', (e) => {
      const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'];
      if (movementKeys.includes(e.code)) {
        this.pressedKeys.add(e.code);
        // Оновлюємо напрямок руху на останню натиснуту клавішу
        const keyMap = {
          'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
          'ArrowDown': [1, 0], 'KeyS': [1, 0],
          'ArrowLeft': [0, -1], 'KeyA': [0, -1],
          'ArrowRight': [0, 1], 'KeyD': [0, 1]
        };
        this.playerDirection = keyMap[e.code];
      }
      // --- Додаємо прапорець для пробілу ---
      if (e.code === 'Space') {
        if (!this.spacePressed) {
          this.spacePressed = true;
          this.handleKeyPress(e);
        }
        e.preventDefault();
        return;
      }
      this.handleKeyPress(e);
      // Установка мины по X
      if (e.code === 'KeyX') {
        this.tryPlaceMine();
      }
      // --- Додаємо розмінування міни по R ---
      if (e.code === 'KeyR') {
        this.tryDefuseMine();
      }
    });
    
    document.addEventListener('keyup', (e) => {
      const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'];
      if (movementKeys.includes(e.code)) {
        this.pressedKeys.delete(e.code);
        // Якщо жодна клавіша не затиснута — зупиняємо рух
        if (this.pressedKeys.size === 0) {
          this.playerDirection = null;
        } else {
          // Якщо ще є затиснуті — рухаємося у напрямку останньої з них
          const lastKey = Array.from(this.pressedKeys).slice(-1)[0];
          const keyMap = {
            'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
            'ArrowDown': [1, 0], 'KeyS': [1, 0],
            'ArrowLeft': [0, -1], 'KeyA': [0, -1],
            'ArrowRight': [0, 1], 'KeyD': [0, 1]
          };
          this.playerDirection = keyMap[lastKey];
        }
      }
      // --- Скидаємо прапорець для пробілу ---
      if (e.code === 'Space') {
        this.spacePressed = false;
      }
    });
    
    this.difficultySelect.addEventListener('change', (e) => {
      this.difficulty = e.target.value;
      this.updateDifficultySettings();
      this.updateStats();
    });
  }

  updateDifficultySettings() {
    switch(this.difficulty) {
      case 'easy':
        this.zombieSpawnRate = 5000;
        this.itemSpawnRate = 8000;
        this.safeZoneRate = 15000;
        break;
      case 'medium':
        this.zombieSpawnRate = 4000;
        this.itemSpawnRate = 7000;
        this.safeZoneRate = 12000;
        break;
      case 'hard':
        this.zombieSpawnRate = 3000;
        this.itemSpawnRate = 6000;
        this.safeZoneRate = 10000;
        break;
      case 'nightmare':
        this.zombieSpawnRate = 2000;
        this.itemSpawnRate = 5000;
        this.safeZoneRate = 8000;
        break;
    }
  }

  clearAllIntervals() {
    if (this.timerInterval) clearInterval(this.timerInterval);
    if (this.playerMoveInterval) clearInterval(this.playerMoveInterval);
    if (this.zombieMoveInterval) clearInterval(this.zombieMoveInterval);
    if (this.eventInterval) clearInterval(this.eventInterval);
    if (this.itemSpawnInterval) clearInterval(this.itemSpawnInterval);
    if (this.zombieTypeChangeInterval) clearInterval(this.zombieTypeChangeInterval);
    if (this.collisionCheckInterval) clearInterval(this.collisionCheckInterval);
    if (this.ammoTimeout) clearTimeout(this.ammoTimeout);
    if (this.healthTimeout) clearTimeout(this.healthTimeout);
    if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
    if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
    if (this.knifeTimeout) clearTimeout(this.knifeTimeout);
    if (this.safeZoneTimeout) clearTimeout(this.safeZoneTimeout);
    if (this.safeZoneAmmoInterval) clearInterval(this.safeZoneAmmoInterval);
    if (this.safeZoneShieldInterval) clearInterval(this.safeZoneShieldInterval);
    // Скидаємо натиснуті клавіші
    this.pressedKeys.clear();
  }

  newGame() {
    this.clearAllIntervals();
    this.isGameActive = true;
    this.isPaused = false;
    this.startTime = Date.now();
    this.playerPos = [1, 1];
    this.playerDirection = null;
    this.activeMines = [];
    
    // Скидання статистики
    this.playerHealth = 100;
    this.playerShield = 0;
    this.playerAmmo = 10;
    this.playerLevel = 1;
    this.zombiesKilled = 0;
    this.survivalTime = 0;
    
    // Скидання предметів
    this.ammoPos = null;
    this.ammoVisible = false;
    this.healthPos = null;
    this.healthVisible = false;
    this.shieldPos = null;
    this.shieldVisible = false;
    this.pickaxePos = null;
    this.pickaxeVisible = false;
    this.playerHasPickaxe = false;
    this.knifePos = null;
    this.knifeVisible = false;
    this.playerHasKnife = true; // Ніж одразу у гравця
    this.playerKnifeUses = 0;   // 6 ударів доступно
    this.minePos = null;
    this.mineVisible = false;
    this.playerMines = 0;
    this.safeZones = [];
    this.exitPos = null;
    this.exitVisible = false;
    
    // Скидання захисту від спаму
    this.lastDamageTime = 0;
    
    // Очищення таймерів
    if (this.ammoTimeout) clearTimeout(this.ammoTimeout);
    if (this.healthTimeout) clearTimeout(this.healthTimeout);
    if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
    if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
    if (this.knifeTimeout) clearTimeout(this.knifeTimeout);
    if (this.safeZoneTimeout) clearTimeout(this.safeZoneTimeout);
    
    // Скидаємо натиснуті клавіші
    this.pressedKeys.clear();
    
    // Генерація лабіринту
    const generator = new MazeGenerator(this.size);
    this.maze = generator.maze.map(row => [...row]);
    
    // Ініціалізація зомбі
    this.zombies = [];
    this.spawnInitialZombies();
    
    this.renderMaze();
    this.updateStatus('playing');
    this.updateStats();
    this.startTimer();
    this.startPlayerAutoMove();
    this.startZombieAI();
    this.startCollisionCheck();
    this.startItemSpawning();
    this.startSafeZoneSpawning();
    this.startZombieTypeChange();
    this.startRandomMazeEvents();
    
    this.newGameBtn.textContent = '🔄 Нова гра';
    this.pauseBtn.disabled = false;
    this.winnerOverlay.style.display = 'none';
    
    if (this.audioStart) { this.audioStart.currentTime = 0; this.audioStart.play(); }
  }

  spawnInitialZombies() {
    const initialZombieCount = this.difficulty === 'easy' ? 3 : 
                              this.difficulty === 'medium' ? 5 :
                              this.difficulty === 'hard' ? 9 : 12;
    
    for (let i = 0; i < initialZombieCount; i++) {
      this.spawnZombie();
    }
  }

  spawnZombie() {
    const pos = this.getRandomEmptyPosition();
    if (!pos) return; // Не спавнити, якщо немає місця
    const zombieType = Math.random() < 0.1 ? 'boss' : 
                      Math.random() < 0.3 ? 'fast' : 'normal';
    
    let health;
    switch(zombieType) {
      case 'boss': health = 5; break;
      case 'fast': health = 3; break;
      default: health = 2; break;
    }
    
    this.zombies.push({
      pos: pos,
      type: zombieType,
      health: health,
      maxHealth: health,
      speed: zombieType === 'fast' ? 80 : zombieType === 'boss' ? 220 : 140,
      state: 'patrolling',
      direction: [0, 1],
      path: [],
      pathIndex: 0,
      lastMoveTime: Date.now(),
      stunnedUntil: 0,
      lastShotTime: 0,
      // === НОВИЙ ІНВЕНТАР ЗОМБІ ===
      inventory: {
        shield: 0,
        ammo: 0,
        level: 1,
        hasPickaxe: false,
        hasKnife: false,
        mines: 0,
        mineDetectorUses: 0
      }
    });
  }

  getRandomEmptyPosition() {
    let row, col, attempts = 0;
    do {
      row = Math.floor(Math.random() * (this.size - 2)) + 1;
      col = Math.floor(Math.random() * (this.size - 2)) + 1;
      attempts++;
      if (attempts > 1000) return null; // Не знайдено вільного місця
    } while (
      this.maze[row][col] === 1 ||
      (row === this.playerPos[0] && col === this.playerPos[1]) ||
      this.zombies.some(z => z.pos[0] === row && z.pos[1] === col) ||
      this.safeZones.some(sz => sz[0] === row && sz[1] === col)
    );
    return [row, col];
  }

  renderMaze() {
    this.mazeEl.innerHTML = '';
    this.mazeEl.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
    
    for (let row = 0; row < this.size; row++) {
      for (let col = 0; col < this.size; col++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        
        if (this.maze[row][col] === 1) {
          cell.classList.add('wall');
        } else {
          cell.classList.add('path');
        }
        
        if (row === 1 && col === 1) cell.classList.add('start');
        
        if (this.exitVisible && this.exitPos && row === this.exitPos[0] && col === this.exitPos[1]) {
          cell.classList.add('end');
        }
        
        if (row === this.playerPos[0] && col === this.playerPos[1]) {
          cell.classList.add('player');
        }
        
        for (const zombie of this.zombies) {
          if (row === zombie.pos[0] && col === zombie.pos[1]) {
            cell.classList.add('zombie');
            if (zombie.type === 'fast') cell.classList.add('zombie-fast');
            if (zombie.type === 'boss') {
              cell.classList.add('zombie-boss');
              cell.innerHTML = '<span style="font-size:15px;">💀</span>';
            }
            if (zombie.health < zombie.maxHealth) {
              const healthPercent = (zombie.health / zombie.maxHealth) * 100;
              let healthColor = healthPercent < 25 ? '#ff0000' : healthPercent < 50 ? '#ffff00' : '#00ff00';
              cell.style.border = `2px solid ${healthColor}`;
              cell.style.boxShadow = `0 0 8px ${healthColor}`;
            }
          }
        }
        
        if (this.ammoVisible && this.ammoPos && row === this.ammoPos[0] && col === this.ammoPos[1]) {
          cell.classList.add('ammo-cell');
          cell.innerHTML = '<span style="font-size:12px;">🔫</span>';
        }
        
        if (this.healthVisible && this.healthPos && row === this.healthPos[0] && col === this.healthPos[1]) {
          cell.classList.add('health-cell');
          cell.innerHTML = '<span style="font-size:12px;">❤️</span>';
        }
        
        if (this.shieldVisible && this.shieldPos && row === this.shieldPos[0] && col === this.shieldPos[1]) {
          cell.classList.add('shield-cell');
          cell.innerHTML = '<span style="font-size:12px;">🛡️</span>';
        }
        
        if (this.pickaxeVisible && this.pickaxePos && row === this.pickaxePos[0] && col === this.pickaxePos[1]) {
          cell.classList.add('pickaxe-cell');
          cell.innerHTML = '<span style="font-size:12px;">🪓</span>';
        }
        
        if (this.knifeVisible && this.knifePos && row === this.knifePos[0] && col === this.knifePos[1]) {
          cell.classList.add('knife-cell');
          cell.innerHTML = '<span style="font-size:12px;">🔪</span>';
        }
        
        if (this.safeZones.some(sz => sz[0] === row && sz[1] === col)) {
          cell.classList.add('safe-zone');
        }
        
        if (this.mineVisible && this.minePos && row === this.minePos[0] && col === this.minePos[1]) {
          cell.classList.add('mine-cell', 'mine-item');
          cell.innerHTML = '<span style="font-size:13px;">💣</span>';
        }
        
        const activeMine = this.activeMines.find(m => m.pos[0] === row && m.pos[1] === col);
        if (activeMine) {
            cell.classList.add('mine-cell');
            if (activeMine.placedBy === 'player') {
                cell.style.border = '2px solid #ff2222';
            } else { // Zombie mine
                cell.classList.add('zombie-mine-cell');
            }
        }
        
        if (this.mineDetectorVisible && this.mineDetectorPos && row === this.mineDetectorPos[0] && col === this.mineDetectorPos[1]) {
          cell.classList.add('mine-detector-cell');
          cell.innerHTML = '<span style="font-size:13px;">🧰</span>';
        }
        
        this.mazeEl.appendChild(cell);
      }
    }
  }

  handleKeyPress(e) {
    if (!this.isGameActive || this.isPaused) return;
    
    const keyMap = {
      'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
      'ArrowDown': [1, 0], 'KeyS': [1, 0],
      'ArrowLeft': [0, -1], 'KeyA': [0, -1],
      'ArrowRight': [0, 1], 'KeyD': [0, 1]
    };
    
    const direction = keyMap[e.code];
    if (direction) {
      e.preventDefault();
      this.playerDirection = direction;
    }
    
    if (e.code === 'Space') {
      e.preventDefault();
      this.shoot();
    }
    
    if (e.code === 'KeyE' && this.playerHasPickaxe) {
      this.tryBreakWall();
    }
  }

  shoot() {
    const movementKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD'];
    const isMoving = movementKeys.some(key => this.pressedKeys.has(key));
    
    const inSafeZone = this.safeZones.some(sz => 
      sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]
    );
    if (inSafeZone) {
      this.showEventNotification('❌ У безпечній зоні не можна атакувати!');
      return;
    }
    
    if (isMoving) {
      this.showEventNotification('❌ Не можна стріляти під час руху! Зупиніться!');
      return;
    }
    
    const zombieOnPlayer = this.zombies.findIndex(z => 
      z.pos[0] === this.playerPos[0] && z.pos[1] === this.playerPos[1]
    );
    
    if (zombieOnPlayer !== -1) {
      if (this.playerHasKnife) {
        this.meleeAttack();
      } else {
        this.showEventNotification('❌ Потрібен ніж для ближнього бою!');
      }
    } else {
      if (this.playerAmmo > 0) {
        this.rangedAttack();
      } else {
        this.showEventNotification('❌ Немає патронів для стрільби!');
      }
    }
  }

  meleeAttack() {
    const inSafeZone = this.safeZones.some(sz => 
      sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]
    );
    if (inSafeZone) return;
    if (!this.playerHasKnife) {
      this.showEventNotification('❌ Потрібен ніж для ближнього бою!');
      return;
    }
    if (this.playerKnifeUses >= 6) {
      this.showEventNotification('🔪 Ніж зламався! Потрібен новий ніж!');
      this.playerHasKnife = false;
      this.playerKnifeUses = 0;
      this.updateStats();
      return;
    }
    
    const zombieOnPlayer = this.zombies.findIndex(z => 
      z.pos[0] === this.playerPos[0] && z.pos[1] === this.playerPos[1]
    );
    
    if (zombieOnPlayer !== -1) {
      // Збільшуємо лічильник використань ножа ПЕРЕД атакою
      this.playerKnifeUses++;
      
      if (Math.random() < 0.65) {
        const zombie = this.zombies[zombieOnPlayer];
        zombie.health--;
        if (this.audioZombieHit) { this.audioZombieHit.currentTime = 0; this.audioZombieHit.play(); }
        if (zombie.health <= 0) {
          this.zombies.splice(zombieOnPlayer, 1);
          this.zombiesKilled++;
          if (this.audioZombieKill) { this.audioZombieKill.currentTime = 0; this.audioZombieKill.play(); }
          
          if (this.zombies.length === 0) {
            this.spawnExit();
            this.showEventNotification('🏆 Всі зомбі знищені! Знайдіть вихід!');
          }
        }
        this.renderMaze();
        this.updateStats();
      } else {
        this.showEventNotification('🔪 Промах!');
      }
    } else {
      this.showEventNotification('❌ Немає зомбі для атаки ножем!');
    }
    
    if (this.audioKnife) { this.audioKnife.currentTime = 0; this.audioKnife.play(); }
  }

  rangedAttack() {
    if (this.playerAmmo <= 0) {
      this.showEventNotification('❌ Немає патронів для стрільби!');
      return;
    }
    
    this.playerAmmo--;
    this.updateStats();
    
    if (Math.random() >= 0.5) {
      this.showEventNotification('🔫 Промах!');
      return;
    }
    
    const target = this.findZombieInLineOfSight();
    
    if (target) {
      const zombie = this.zombies[target.index];
      zombie.health--;
      if (this.audioZombieHit) { this.audioZombieHit.currentTime = 0; this.audioZombieHit.play(); }
      if (zombie.health <= 0) {
        this.zombies.splice(target.index, 1);
        this.zombiesKilled++;
        if (this.audioZombieKill) { this.audioZombieKill.currentTime = 0; this.audioZombieKill.play(); }
        
        if (this.zombies.length === 0) {
          this.spawnExit();
          this.showEventNotification('🏆 Всі зомбі знищені! Знайдіть вихід!');
        }
      } else {
        // Повідомлення про промах прибрано
      }
      this.renderMaze();
      this.updateStats();
    } else {
      this.showEventNotification('🔫 Промах!');
    }
    
    if (this.audioGun) { this.audioGun.currentTime = 0; this.audioGun.play(); }
  }

  findZombieInLineOfSight() {
    const directions = [[-1,0],[1,0],[0,-1],[0,1]];
    let closestTarget = null;
    let closestDistance = Infinity;
    
    for (const [dr, dc] of directions) {
      let r = this.playerPos[0] + dr;
      let c = this.playerPos[1] + dc;
      let distance = 1;
      
      while (r >= 0 && r < this.size && c >= 0 && c < this.size && this.maze[r][c] === 0) {
        const zombieIndex = this.zombies.findIndex(z => z.pos[0] === r && z.pos[1] === c);
        if (zombieIndex !== -1) {
          if (distance < closestDistance) {
            closestTarget = { index: zombieIndex, distance: distance };
            closestDistance = distance;
          }
          break;
        }
        r += dr;
        c += dc;
        distance++;
      }
    }
    
    return closestTarget;
  }

  startPlayerAutoMove() {
    if (this.playerMoveInterval) clearInterval(this.playerMoveInterval);
    this.playerMoveInterval = setInterval(() => {
      if (!this.isGameActive || this.isPaused || Date.now() < this.playerBlockedUntil) return;
      this.checkSafeZone();
      if (!this.playerDirection) return;
      const newRow = this.playerPos[0] + this.playerDirection[0];
      const newCol = this.playerPos[1] + this.playerDirection[1];
      if (this.isValidMove(newRow, newCol, 'player')) {
        this.playerPos = [newRow, newCol];
        if (this.audioStep) { this.audioStep.currentTime = 0; this.audioStep.play(); }
        this.checkItemPickup();
        this.checkSafeZone();
        this.renderMaze();
      }
    }, 100);
  }

  isValidMove(row, col, entityType = 'zombie') {
    if (!(row >= 0 && row < this.size && col >= 0 && col < this.size && this.maze[row][col] === 0)) {
        return false;
    }
    // Заборона для зомбі заходити у зону безпеки
    if (entityType === 'zombie' && this.safeZones.some(sz => sz[0] === row && sz[1] === col)) {
        return false;
    }
    return true;
  }

  checkItemPickup() {
    let picked = false;
    // Гравець підбирає предмети
    if (this.ammoVisible && this.ammoPos && this.playerPos[0] === this.ammoPos[0] && this.playerPos[1] === this.ammoPos[1]) {
      this.playerAmmo += 5;
      this.hideAmmo(); picked = true;
    }
    if (this.healthVisible && this.healthPos && this.playerPos[0] === this.healthPos[0] && this.playerPos[1] === this.healthPos[1]) {
      this.playerHealth = Math.min(100, this.playerHealth + 25);
      this.hideHealth(); picked = true;
    }
    if (this.shieldVisible && this.shieldPos && this.playerPos[0] === this.shieldPos[0] && this.playerPos[1] === this.shieldPos[1]) {
      this.playerShield = Math.min(100, this.playerShield + 50);
      this.hideShield(); picked = true;
    }
    if (this.pickaxeVisible && this.pickaxePos && this.playerPos[0] === this.pickaxePos[0] && this.playerPos[1] === this.pickaxePos[1]) {
      this.playerHasPickaxe = true;
      this.hidePickaxe(); picked = true;
    }
    if (this.knifeVisible && this.knifePos && this.playerPos[0] === this.knifePos[0] && this.playerPos[1] === this.knifePos[1]) {
      this.playerHasKnife = true;
      this.playerKnifeUses = 0; // Скидаємо лічильник при підборі нового ножа
      this.hideKnife(); picked = true;
    }
    if (this.mineVisible && this.minePos && this.playerPos[0] === this.minePos[0] && this.playerPos[1] === this.minePos[1]) {
      this.playerMines += 1;
      this.hideMine(); picked = true;
    }
    // --- Додаємо підбір мінного детектора гравцем ---
    if (this.mineDetectorVisible && this.mineDetectorPos && this.playerPos[0] === this.mineDetectorPos[0] && this.playerPos[1] === this.mineDetectorPos[1]) {
      this.playerMineDetectorUses = 3;
      this.hideMineDetector(); picked = true;
      this.showEventNotification('🧰 Ви підібрали детектор мін!');
    }
    if (picked) {
        if (this.audioPickup) { this.audioPickup.currentTime = 0; this.audioPickup.play(); }
        this.updateStats();
        this.renderMaze();
    }
  }

  zombieCheckItemPickup(zombie) {
      let picked = false;
      if (this.ammoVisible && this.ammoPos && zombie.pos[0] === this.ammoPos[0] && zombie.pos[1] === this.ammoPos[1]) {
          zombie.inventory.ammo += 5;
          this.hideAmmo(); picked = true;
          this.showEventNotification('🧟‍♂️ Зомбі підібрав патрони!');
      }
      if (this.healthVisible && this.healthPos && zombie.pos[0] === this.healthPos[0] && zombie.pos[1] === this.healthPos[1]) {
          zombie.health = Math.min(zombie.maxHealth, zombie.health + 1); // Зомбі відновлює 1 HP
          this.hideHealth(); picked = true;
          this.showEventNotification('🧟‍♂️ Зомбі підібрав здоров\'я!');
      }
      if (this.shieldVisible && this.shieldPos && zombie.pos[0] === this.shieldPos[0] && zombie.pos[1] === this.shieldPos[1]) {
          zombie.inventory.shield += 50;
          this.hideShield(); picked = true;
          this.showEventNotification('🧟‍♂️ Зомбі підібрав щит!');
      }
      if (this.pickaxeVisible && this.pickaxePos && zombie.pos[0] === this.pickaxePos[0] && zombie.pos[1] === this.pickaxePos[1]) {
          zombie.inventory.hasPickaxe = true;
          this.hidePickaxe(); picked = true;
          this.showEventNotification('🧟‍♂️ Зомбі підібрав топор!');
      }
      if (this.knifeVisible && this.knifePos && zombie.pos[0] === this.knifePos[0] && zombie.pos[1] === this.knifePos[1]) {
          zombie.inventory.hasKnife = true;
          this.hideKnife(); picked = true;
          this.showEventNotification('🧟‍♂️ Зомбі підібрав ніж!');
      }
      if (this.mineVisible && this.minePos && zombie.pos[0] === this.minePos[0] && zombie.pos[1] === this.minePos[1]) {
          zombie.inventory.mines += 1;
          this.hideMine(); picked = true;
          this.showEventNotification('🧟‍♂️ Зомбі підібрав міну!');
      }
      if (this.mineDetectorVisible && this.mineDetectorPos && zombie.pos[0] === this.mineDetectorPos[0] && zombie.pos[1] === this.mineDetectorPos[1]) {
          zombie.inventory.mineDetectorUses = 3;
          this.hideMineDetector(); picked = true;
          this.showEventNotification('🧟‍♂️ Зомбі підібрав детектор мін!');
      }
      if (picked) {
          if (this.audioPickup) { this.audioPickup.currentTime = 0; this.audioPickup.play(); }
          this.renderMaze();
      }
  }

  checkSafeZone() {
    const inSafeZone = this.safeZones.some(sz => 
      sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]
    );
    if (inSafeZone && !this.wasInSafeZone) {
      if (this.audioSafeZone) { this.audioSafeZone.currentTime = 0; this.audioSafeZone.play(); }
    }
    this.wasInSafeZone = inSafeZone;
    
    if (inSafeZone) {
      this.playerStatusEl.textContent = '🔋 Зона поповнення ресурсів! Стійте нерухомо!';
      this.playerStatusEl.style.background = 'rgba(46, 204, 113, 0.8)';
      if (!this.safeZoneAmmoInterval) {
        this.safeZoneAmmoInterval = setInterval(() => {
          if (!this.isGameActive || this.isPaused) return;
          const stillInSafeZone = this.safeZones.some(sz => sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]);
          const isMoving = !!this.playerDirection;
          if (stillInSafeZone && !isMoving) {
            this.playerAmmo += 1; this.updateStats(); this.showEventNotification('🔫 +1 патрон (зона)');
          }
        }, 2000);
      }
      if (!this.safeZoneShieldInterval) {
        this.safeZoneShieldInterval = setInterval(() => {
          if (!this.isGameActive || this.isPaused) return;
          const stillInSafeZone = this.safeZones.some(sz => sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]);
          const isMoving = !!this.playerDirection;
          if (stillInSafeZone && !isMoving) {
            this.playerShield = Math.min(100, this.playerShield + 10); this.updateStats(); this.showEventNotification('🛡️ +10 щита (зона)');
          }
        }, 3000);
      }
    } else {
      this.playerStatusEl.textContent = '🧟‍♂️ Виживає...';
      this.playerStatusEl.style.background = 'rgba(52, 152, 219, 0.8)';
      if (this.safeZoneAmmoInterval) { clearInterval(this.safeZoneAmmoInterval); this.safeZoneAmmoInterval = null; }
      if (this.safeZoneShieldInterval) { clearInterval(this.safeZoneShieldInterval); this.safeZoneShieldInterval = null; }
    }
  }

  startZombieAI() {
    if (this.zombieMoveInterval) clearInterval(this.zombieMoveInterval);
    
    setTimeout(() => {
      if (!this.isGameActive) return;
      this.zombieMoveInterval = setInterval(() => {
        if (!this.isGameActive || this.isPaused) return;
        this.moveZombies();
      }, 50);
    }, 2000);
  }

  startCollisionCheck() {
    if (this.collisionCheckInterval) clearInterval(this.collisionCheckInterval);
    
    this.collisionCheckInterval = setInterval(() => {
      if (!this.isGameActive || this.isPaused) return;
      this.checkCollision();
    }, 50);
  }

  moveZombies() {
  const now = Date.now();
  for (const zombie of this.zombies) {
    if (!zombie.lastMoveTime) zombie.lastMoveTime = now;
    if (zombie.stunnedUntil && now < zombie.stunnedUntil) continue;
    // --- нова логіка ---
    // Додаємо перевірку: якщо зомбі на одній клітинці з гравцем — не стріляє!
    if (
      this.canSeeTarget(zombie, this.maze, this.playerPos) &&
      zombie.inventory.ammo > 0 &&
      !(zombie.pos[0] === this.playerPos[0] && zombie.pos[1] === this.playerPos[1])
    ) {
      // Якщо бачить гравця і є патрони — не рухається, а стріляє
      if (now - zombie.lastShotTime > 142) {
        zombie.lastShotTime = now;
        setTimeout(() => this.zombieShoot(zombie), 200);
      }
      continue; // Не рухається!
    }
    // --- кінець нової логіки ---
    if (now - zombie.lastMoveTime >= zombie.speed) {
      this.moveSingleZombie(zombie);
      zombie.lastMoveTime = now;
      if (Math.abs(zombie.pos[0] - this.playerPos[0]) + Math.abs(zombie.pos[1] - this.playerPos[1]) <= 2) {
        if (this.audioZombie) { this.audioZombie.currentTime = 0; this.audioZombie.play(); }
      }
    }
  }
  this.checkZombieInteractions(this.zombies, this.maze);
  this.renderMaze();
  this.updateStats();
  this.checkMinesExplosion();
  this.checkPlayerMineExplosion();
}
  
  moveSingleZombie(zombie) {
      // 1. Логіка використання топора
      const nextPosOnPath = this.getNextStepOnPath(zombie);
      if (nextPosOnPath && this.maze[nextPosOnPath[0]][nextPosOnPath[1]] === 1) {
          if (zombie.inventory.hasPickaxe) {
              this.maze[nextPosOnPath[0]][nextPosOnPath[1]] = 0;
              zombie.inventory.hasPickaxe = false;
              zombie.pos = nextPosOnPath;
              if (this.audioBreakWall) { this.audioBreakWall.currentTime = 0; this.audioBreakWall.play(); }
              this.showEventNotification('🧟‍♂️ Зомбі прорубав стіну!');
              this.zombies.forEach(z => { z.path = []; z.pathIndex = 0; });
              this.zombieCheckItemPickup(zombie);
              return;
          }
      }

      // 2. Основний рух
      this.moveZombiesGeneric([zombie], this.maze, this.playerPos);

      // 3. Підбір предметів після руху
      this.zombieCheckItemPickup(zombie);

      // 4. Встановлення міни
      if (zombie.inventory.mines > 0 && zombie.state === 'patrolling' && Math.random() < 0.05) {
          this.tryPlaceZombieMine(zombie);
      }

      // 5. Автоматичне розмінування мін гравця
      if (zombie.inventory.mineDetectorUses > 0) {
        const mineIdx = this.activeMines.findIndex(m => m.pos[0] === zombie.pos[0] && m.pos[1] === zombie.pos[1] && m.placedBy === 'player');
        if (mineIdx !== -1) {
          this.activeMines.splice(mineIdx, 1);
          zombie.inventory.mineDetectorUses--;
          this.showEventNotification('🧟‍♂️ Зомбі розмінував міну гравця!');
          this.renderMaze();
          if (this.audioMineDefuse) { this.audioMineDefuse.currentTime = 0; this.audioMineDefuse.play(); }
        }
      }
  }

  getNextStepOnPath(zombie) {
      if (zombie.path && zombie.pathIndex < zombie.path.length) {
          return zombie.path[zombie.pathIndex];
      }
      return null;
  }
    
  zombieShoot(zombie) {
    if (!this.isGameActive || this.isPaused || zombie.inventory.ammo <= 0) return;
    
    zombie.inventory.ammo--;
    // if (this.audioGun) { this.audioGun.currentTime = 0; this.audioGun.play(); } // видаляємо цей рядок

    // Така ж вірогідність попадання, як у гравця (50% шанс)
    if (Math.random() >= 0.5) {
        if (this.audioGun) { this.audioGun.currentTime = 0; this.audioGun.play(); } // додаємо сюди
        this.showEventNotification(`🧟‍♂️ Зомбі влучив у вас!`);
        let damage = 15;
        if (zombie.inventory && zombie.inventory.hasKnife) {
          damage = Math.round(damage * 1.5); // +50% урону
        }
        if (this.playerShield > 0) {
            const shieldDamage = Math.min(this.playerShield, damage);
            this.playerShield -= shieldDamage;
            const remainingDamage = damage - shieldDamage;
            this.playerHealth -= remainingDamage;
        } else {
            this.playerHealth -= damage;
        }
        this.updateStats();
        if (this.playerHealth <= 0) {
            this.endGame(false);
        }
    } else {
        this.showEventNotification(`🧟‍♂️ Зомбі промахнувся!`);
    }
  }

  moveZombiesGeneric(zombies, maze, targetPos) {
    for (const zombie of zombies) {
      if (zombie.path && zombie.pathIndex < zombie.path.length) {
        const nextPos = zombie.path[zombie.pathIndex];
        if (!this.isValidMove(nextPos[0], nextPos[1], 'zombie') || (this.isStartActive && nextPos[0] === 1 && nextPos[1] === 1)) {
          zombie.path = []; zombie.pathIndex = 0;
        }
      }

      const prevState = this.zombieLastSeenState.get(zombie) || 'patrolling';
      if (this.canSeeTarget(zombie, maze, targetPos)) {
        zombie.state = 'chasing';
        if (prevState !== 'chasing') { if (this.audioZombieSee) { this.audioZombieSee.currentTime = 0; this.audioZombieSee.play(); } }
      } else {
        zombie.state = 'patrolling';
      }
      this.zombieLastSeenState.set(zombie, zombie.state);

      if (zombie.state === 'chasing') {
        if (!zombie.path || zombie.pathIndex >= zombie.path.length || Math.random() < 0.1) {
          zombie.path = this.findPathAStarWithStartBlock(maze, zombie.pos, targetPos, 'zombie');
          zombie.pathIndex = 1;
        }
        if (zombie.path && zombie.pathIndex < zombie.path.length) {
          if (!(this.isStartActive && zombie.path[zombie.pathIndex][0] === 1 && zombie.path[zombie.pathIndex][1] === 1)) {
            zombie.pos = zombie.path[zombie.pathIndex];
          }
          zombie.pathIndex++;
        }
      } else {
        const possibleDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        const prevDirection = zombie.direction;
        const reverseDirection = prevDirection ? [-prevDirection[0], -prevDirection[1]] : null;
        let validDirections = possibleDirections.filter(dir => {
          const checkPos = [zombie.pos[0] + dir[0], zombie.pos[1] + dir[1]];
          if (this.isStartActive && checkPos[0] === 1 && checkPos[1] === 1) return false;
          if (reverseDirection && dir[0] === reverseDirection[0] && dir[1] === reverseDirection[1]) return false;
          return this.isValidMove(checkPos[0], checkPos[1], 'zombie');
        });
        if (validDirections.length === 0 && reverseDirection) {
          const backPos = [zombie.pos[0] + reverseDirection[0], zombie.pos[1] + reverseDirection[1]];
          if (this.isValidMove(backPos[0], backPos[1], 'zombie') && !(this.isStartActive && backPos[0] === 1 && backPos[1] === 1)) {
            validDirections = [reverseDirection];
          }
        }
        if (validDirections.length > 1 && Math.random() < 0.3) {
          zombie.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
        } else if (validDirections.length > 0) {
          const nextPos = [zombie.pos[0] + (zombie.direction ? zombie.direction[0] : 0), zombie.pos[1] + (zombie.direction ? zombie.direction[1] : 0)];
          if (!zombie.direction || !this.isValidMove(nextPos[0], nextPos[1], 'zombie') || (this.isStartActive && nextPos[0] === 1 && nextPos[1] === 1)) {
            zombie.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
          }
        }
        if (zombie.direction) {
          const nextPos = [zombie.pos[0] + zombie.direction[0], zombie.pos[1] + zombie.direction[1]];
          if (!(this.isStartActive && nextPos[0] === 1 && nextPos[1] === 1)) {
            zombie.pos = nextPos;
          }
        }
      }
    }
  }

  canSeeTarget(zombie, maze, targetPos) {
    if (targetPos[0] === 1 && targetPos[1] === 1) return false;
    const [zRow, zCol] = zombie.pos;
    const [tRow, tCol] = targetPos;
    const lineOfSightDistance = 15;
    if (zRow === tRow && Math.abs(zCol - tCol) < lineOfSightDistance) {
      const start = Math.min(zCol, tCol);
      const end = Math.max(zCol, tCol);
      let wallFound = false;
      for (let i = start + 1; i < end; i++) { if (maze[zRow][i] === 1) { wallFound = true; break; } }
      if (!wallFound) return true;
    }
    if (zCol === tCol && Math.abs(zRow - tRow) < lineOfSightDistance) {
      const start = Math.min(zRow, tRow);
      const end = Math.max(zRow, tRow);
      let wallFound = false;
      for (let i = start + 1; i < end; i++) { if (maze[i][zCol] === 1) { wallFound = true; break; } }
      if (!wallFound) return true;
    }
    return false;
  }

  findPathAStarWithStartBlock(maze, start, goal, entityType = 'zombie') {
    const size = this.size;
    const openSet = [start];
    const cameFrom = {};
    const gScore = Array(size).fill().map(() => Array(size).fill(Infinity));
    const fScore = Array(size).fill().map(() => Array(size).fill(Infinity));
    gScore[start[0]][start[1]] = 0;
    fScore[start[0]][start[1]] = this.heuristic(start, goal);

    function posToStr(pos) { return pos[0] + ',' + pos[1]; }
    function strToPos(str) { return str.split(',').map(Number); }

    while (openSet.length > 0) {
      let currentIdx = 0;
      for (let i = 1; i < openSet.length; i++) {
        if (fScore[openSet[i][0]][openSet[i][1]] < fScore[openSet[currentIdx][0]][openSet[currentIdx][1]]) {
          currentIdx = i;
        }
      }
      const current = openSet.splice(currentIdx, 1)[0];
      if (current[0] === goal[0] && current[1] === goal[1]) {
        let path = [goal]; let currStr = posToStr(goal);
        while (cameFrom[currStr]) { currStr = cameFrom[currStr]; path.push(strToPos(currStr)); }
        return path.reverse();
      }
      const directions = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr, dc] of directions) {
        const nr = current[0] + dr, nc = current[1] + dc;
        if (this.isValidMove(nr, nc, entityType) && !(this.isStartActive && nr === 1 && nc === 1)) {
          const tentative_gScore = gScore[current[0]][current[1]] + 1;
          if (tentative_gScore < gScore[nr][nc]) {
            cameFrom[posToStr([nr, nc])] = posToStr(current);
            gScore[nr][nc] = tentative_gScore;
            fScore[nr][nc] = tentative_gScore + this.heuristic([nr, nc], goal);
            if (!openSet.some(([r, c]) => r === nr && c === nc)) {
              openSet.push([nr, nc]);
            }
          }
        }
      }
    }
    return [start];
  }

  heuristic(pos, goal) {
    return Math.abs(pos[0] - goal[0]) + Math.abs(pos[1] - goal[1]);
  }

  checkZombieInteractions(zombies, maze) {
    const prevZombieCount = this._prevZombieCount ?? zombies.length;
    const toRemove = new Set();
    const maxZombies = 418;

    for (let i = 0; i < zombies.length; i++) {
        if (toRemove.has(i)) continue;
        for (let j = i + 1; j < zombies.length; j++) {
            if (toRemove.has(j)) continue;

            const z1 = zombies[i];
            const z2 = zombies[j];

            if (z1.pos[0] === z2.pos[0] && z1.pos[1] === z2.pos[1] && z1.type !== z2.type) {
                if (Math.random() < 0.5) { // 50% на 50% - або з'являється новий зомбі, або видаляється один
                    if (zombies.length < maxZombies) {
                        this.spawnZombie();
                    }
                } else { // 50% ймовірність видалення одного з зомбі
                    const toKillIndex = Math.random() < 0.5 ? i : j;
                    toRemove.add(toKillIndex);
                }
                // Break inner loop to prevent multiple interactions for z1 in one cycle
                break;
            }
        }
    }

    if (toRemove.size > 0) {
        const filteredZombies = zombies.filter((_, index) => !toRemove.has(index));
        zombies.length = 0;
        zombies.push(...filteredZombies);
    }
    
    if (prevZombieCount < 3 && zombies.length >= 3) {
        this.startItemSpawning();
        this.startSafeZoneSpawning();
        this.showEventNotification('⚠️ Збільшення популяції зомбі! Предмети та зони знову зʼявляються!');
    }
    this._prevZombieCount = zombies.length;

    this.updateStats();
    if (this.zombies.length === 0 && !this.exitVisible) {
        this.spawnExit();
        this.showEventNotification('🏆 Всі зомбі знищені! Знайдіть вихід!');
    }
  }

  startZombieTypeChange() {
    if (this.zombieTypeChangeInterval) clearInterval(this.zombieTypeChangeInterval);
    this.zombieTypeChangeInterval = setInterval(() => {
      if (!this.isGameActive || this.isPaused || this.zombies.length <= 1) return;
      const randomZombieIndex = Math.floor(Math.random() * this.zombies.length);
      const zombieToChange = this.zombies[randomZombieIndex];
      const newType = Math.random() < 0.1 ? 'boss' : Math.random() < 0.3 ? 'fast' : 'normal';
      let newMaxHealth;
      switch(newType) {
        case 'boss': newMaxHealth = 5; break;
        case 'fast': newMaxHealth = 3; break;
        default: newMaxHealth = 2; break;
      }
      const percent = zombieToChange.health / zombieToChange.maxHealth;
      zombieToChange.type = newType;
      zombieToChange.maxHealth = newMaxHealth;
      zombieToChange.health = Math.max(1, Math.round(percent * newMaxHealth));
      zombieToChange.speed = newType === 'fast' ? 80 : newType === 'boss' ? 220 : 140;
      this.renderMaze(); this.updateStats();
    }, 10000);
  }

  spawnExit() {
    const corners = [[1, this.size-2], [this.size-2, 1], [this.size-2, this.size-2]];
    this.exitPos = corners[Math.floor(Math.random()*corners.length)];
    this.exitVisible = true;
    this.playerStatusEl.textContent = '🏆 Знайдіть червоний квадрат!';
    this.playerStatusEl.style.background = 'rgba(241, 196, 15, 0.8)';
    this.renderMaze(); this.updateStats();
  }

  checkCollision() {
    for (const zombie of this.zombies) {
      if (zombie.pos[0] === this.playerPos[0] && zombie.pos[1] === this.playerPos[1]) {
        const inSafeZone = this.safeZones.some(sz => sz[0] === this.playerPos[0] && sz[1] === this.playerPos[1]);
        if (!inSafeZone) {
          if (Date.now() > this.playerBlockedUntil) {
            this.playerBlockedUntil = Date.now() + 3000;
            this.showEventNotification('🏃‍♂️ Вас знерухомлено на 3 секунди!');
          }
          const currentTime = Date.now();
          if (currentTime - this.lastDamageTime > this.damageCooldown) {
            this.lastDamageTime = currentTime;
            if (this.audioZombieBite) { this.audioZombieBite.currentTime = 0; this.audioZombieBite.play(); }
            let damage = zombie.type === 'boss' ? 30 : zombie.type === 'fast' ? 20 : 15;
            if (zombie.inventory && zombie.inventory.hasKnife) {
              damage = Math.round(damage * 1.5); // +50% урону
            }
            if (this.playerShield > 0) {
              const shieldDamage = Math.min(this.playerShield, damage);
              this.playerShield -= shieldDamage;
              this.playerHealth -= (damage - shieldDamage);
            } else {
              this.playerHealth -= damage;
            }
            this.updateStats();
            this.showEventNotification(`💥 Отримано ${damage} пошкоджень${zombie.inventory && zombie.inventory.hasKnife ? ' (ніж)' : ''}!`);
            if (this.playerHealth <= 0) { this.endGame(false); return; }
          }
        }
      }
    }
    if (this.exitVisible && this.exitPos && this.playerPos[0] === this.exitPos[0] && this.playerPos[1] === this.exitPos[1]) {
      this.endGame(true);
    }
  }

  startItemSpawning() {
    setTimeout(() => this.spawnAmmo(), 30000 + Math.random() * 15000);
    setTimeout(() => this.spawnHealth(), 40000 + Math.random() * 20000);
    setTimeout(() => this.spawnShield(), 60000 + Math.random() * 30000);
    setTimeout(() => this.spawnPickaxe(), 10000 + Math.random() * 8000);
    setTimeout(() => this.spawnKnife(), 12000 + Math.random() * 10000);
    setTimeout(() => this.spawnMine(), 120000 + Math.random() * 60000);
    setTimeout(() => this.spawnMineDetector(), 45000 + Math.random() * 15000);
  }

  spawnAmmo() { 
    if (this.zombies.length < 3) return; 
    if (this.ammoVisible) return; // Захист від накладання циклів
    this.ammoPos = this.getRandomEmptyPosition(); 
    if (this.ammoPos) { 
      this.ammoVisible = true; 
      this.renderMaze(); 
      this.ammoTimeout = setTimeout(() => this.hideAmmo(), 5000); 
    } 
  }
  hideAmmo() { 
    this.ammoVisible = false; 
    this.ammoPos = null; 
    this.renderMaze(); 
    if (this.ammoTimeout) clearTimeout(this.ammoTimeout);
    setTimeout(() => this.spawnAmmo(), 30000 + Math.random() * 15000); 
  }
  
  spawnHealth() { 
    if (this.zombies.length < 3) return; 
    if (this.healthVisible) return; // Захист від накладання циклів
    this.healthPos = this.getRandomEmptyPosition(); 
    if (this.healthPos) { 
      this.healthVisible = true; 
      this.renderMaze(); 
      this.healthTimeout = setTimeout(() => this.hideHealth(), 5000); 
    } 
  }
  hideHealth() { 
    this.healthVisible = false; 
    this.healthPos = null; 
    this.renderMaze(); 
    if (this.healthTimeout) clearTimeout(this.healthTimeout);
    setTimeout(() => this.spawnHealth(), 40000 + Math.random() * 20000); 
  }
  
  spawnShield() { 
    if (this.zombies.length < 3) return; 
    if (this.shieldVisible) return; // Захист від накладання циклів
    this.shieldPos = this.getRandomEmptyPosition(); 
    if (this.shieldPos) { 
      this.shieldVisible = true; 
      this.renderMaze(); 
      this.shieldTimeout = setTimeout(() => this.hideShield(), 5000); 
    } 
  }
  hideShield() { 
    this.shieldVisible = false; 
    this.shieldPos = null; 
    this.renderMaze(); 
    if (this.shieldTimeout) clearTimeout(this.shieldTimeout);
    setTimeout(() => this.spawnShield(), 60000 + Math.random() * 30000); 
  }
  
  spawnPickaxe() { 
    if (!this.isGameActive) return; 
    if (this.pickaxeVisible) return; // Захист від накладання циклів
    this.pickaxePos = this.getRandomEmptyPosition(); 
    if (!this.pickaxePos) { return; } 
    this.pickaxeVisible = true; 
    this.renderMaze(); 
    const duration = 8000 + Math.random() * 4000; 
    this.pickaxeTimeout = setTimeout(() => { this.hidePickaxe(); }, duration); 
  }
  hidePickaxe() {
    this.pickaxeVisible = false;
    this.pickaxePos = null;
    this.renderMaze();
    if (this.pickaxeTimeout) clearTimeout(this.pickaxeTimeout);
    setTimeout(() => this.spawnPickaxe(), 15000 + Math.random() * 10000);
  }
  
  spawnKnife() { 
    if (!this.isGameActive) return; 
    if (this.knifeVisible) return; // Захист від накладання циклів
    this.knifePos = this.getRandomEmptyPosition(); 
    if (!this.knifePos) { return; } 
    this.knifeVisible = true; 
    this.renderMaze(); 
    const duration = 8000 + Math.random() * 4000; 
    this.knifeTimeout = setTimeout(() => { this.hideKnife(); }, duration); 
  }
  hideKnife() { 
    this.knifeVisible = false; 
    this.knifePos = null; 
    this.renderMaze(); 
    if (this.knifeTimeout) clearTimeout(this.knifeTimeout); 
    setTimeout(() => this.spawnKnife(), 20000 + Math.random() * 15000); 
  }
  
  spawnMine() { 
    if (this.mineVisible) return; // Захист від накладання циклів
    this.minePos = this.getRandomEmptyPosition(); 
    if (this.minePos) { 
      this.mineVisible = true; 
      this.renderMaze(); 
      this.mineTimeout = setTimeout(() => this.hideMine(), 6000); 
    } 
  }
  hideMine() { 
    this.mineVisible = false; 
    this.minePos = null; 
    this.renderMaze(); 
    if (this.mineTimeout) clearTimeout(this.mineTimeout); 
    setTimeout(() => this.spawnMine(), 120000 + Math.random() * 60000); 
  }
  
  spawnMineDetector() {
    if (!this.isGameActive) return;
    if (this.mineDetectorVisible) return; // Захист від накладання циклів
    
    // Збалансована логіка: детектор з'являється тільки якщо є активні міни на карті
    const activeMinesCount = this.activeMines.length;
    if (activeMinesCount === 0) {
      // Якщо немає мін, плануємо наступну спробу через довший час
      setTimeout(() => this.spawnMineDetector(), 120000 + Math.random() * 60000); // 2-3 хвилини
      return;
    }
    
    // Якщо є міни, з'являємося з ймовірністю залежно від кількості мін
    const spawnChance = Math.min(0.3 + (activeMinesCount * 0.2), 0.8); // 30-80% шанс
    if (Math.random() > spawnChance) {
      setTimeout(() => this.spawnMineDetector(), 60000 + Math.random() * 30000); // 1-1.5 хвилини
      return;
    }
    
    this.mineDetectorPos = this.getRandomEmptyPosition();
    if (!this.mineDetectorPos) return;
    this.mineDetectorVisible = true;
    this.renderMaze();
    const duration = 12000 + Math.random() * 8000; // Збільшуємо час існування
    this.mineDetectorTimeout = setTimeout(() => { this.hideMineDetector(); }, duration);
  }
  hideMineDetector() {
    this.mineDetectorVisible = false;
    this.mineDetectorPos = null;
    this.renderMaze();
    if (this.mineDetectorTimeout) clearTimeout(this.mineDetectorTimeout);
    
    // Плануємо наступну появу залежно від кількості активних мін
    const activeMinesCount = this.activeMines.length;
    let nextSpawnDelay;
    
    if (activeMinesCount === 0) {
      nextSpawnDelay = 180000 + Math.random() * 120000; // 3-5 хвилин якщо немає мін
    } else if (activeMinesCount <= 2) {
      nextSpawnDelay = 90000 + Math.random() * 60000; // 1.5-2.5 хвилини
    } else {
      nextSpawnDelay = 60000 + Math.random() * 30000; // 1-1.5 хвилини
    }
    
    setTimeout(() => this.spawnMineDetector(), nextSpawnDelay);
  }

  tryBreakWall() {
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    for (const [dr,dc] of dirs) {
      const r = this.playerPos[0] + dr;
      const c = this.playerPos[1] + dc;
      if (r >= 0 && r < this.size && c >= 0 && c < this.size && this.maze[r][c] === 1) {
        this.maze[r][c] = 0;
        this.playerHasPickaxe = false;
        if (this.audioBreakWall) { this.audioBreakWall.currentTime = 0; this.audioBreakWall.play(); }
        this.showEventNotification('🧱 Стіну прорублено!');
        this.zombies.forEach(zombie => { zombie.path = []; zombie.pathIndex = 0; });
        this.renderMaze();
        // this.spawnPickaxeWithDelay(); // ВИДАЛЕНО
        break;
      }
    }
  }

  // Видалити/закоментувати spawnPickaxeWithDelay якщо не використовується більше
  // ... existing code ...
  // Для ножа: нічого не викликати після підбору, спавн лише через hideKnife
  // ... existing code ...

  startSafeZoneSpawning() {
    if (this.zombies.length < 3) return;
    const initialDelay = 3000 + Math.random() * 7000;
    this.safeZoneTimeout = setTimeout(() => { if (!this.isGameActive || this.isPaused) return; this.safeZoneCycle(); }, initialDelay);
  }

  safeZoneCycle() {
    if (this.zombies.length < 3) return;
    const pos = this.getRandomEmptyPosition();
    if (!pos) { // No empty position found
      this.safeZoneTimeout = setTimeout(() => { if (!this.isGameActive || this.isPaused) return; this.safeZoneCycle(); }, 10000);
      return;
    }
    this.safeZones = [pos];
    this.renderMaze();
    this.showEventNotification('🛡️ Зʼявилася безпечна зона!');
    const zoneDuration = 6000 + Math.random() * 8000;
    this.safeZoneTimeout = setTimeout(() => {
      const expiredZone = this.safeZones.pop();
      this.renderMaze();
      if (expiredZone && this.playerPos[0] === expiredZone[0] && this.playerPos[1] === expiredZone[1]) {
        this.playerStatusEl.textContent = '🧟‍♂️ Виживає...';
        this.playerStatusEl.style.background = 'rgba(52, 152, 219, 0.8)';
        if (this.safeZoneAmmoInterval) { clearInterval(this.safeZoneAmmoInterval); this.safeZoneAmmoInterval = null; }
        if (this.safeZoneShieldInterval) { clearInterval(this.safeZoneShieldInterval); this.safeZoneShieldInterval = null; }
      }
      this.safeZoneTimeout = setTimeout(() => { if (!this.isGameActive || this.isPaused) return; this.safeZoneCycle(); }, 10000);
    }, zoneDuration);
  }

  startTimer() {
    if (this.timerInterval) clearInterval(this.timerInterval);
    this.timerInterval = setInterval(() => {
      if (!this.isPaused && this.isGameActive) {
        this.survivalTime = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(this.survivalTime / 60);
        const seconds = this.survivalTime % 60;
        this.timerEl.textContent = `Час виживання: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }, 1000);
  }

  updateStats() {
    document.getElementById('healthDisplay').textContent = this.playerHealth;
    document.getElementById('shieldDisplay').textContent = this.playerShield;
    document.getElementById('ammoDisplay').textContent = this.playerAmmo;
    document.getElementById('zombieCount').textContent = this.zombies.length;
    document.getElementById('levelDisplay').textContent = this.playerLevel;
    
    if (!document.getElementById('pickaxeIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const pickaxeDiv = document.createElement('div');
      pickaxeDiv.className = 'stat-item'; pickaxeDiv.id = 'pickaxeIndicator';
      statsBar.appendChild(pickaxeDiv);
    }
    document.getElementById('pickaxeIndicator').innerHTML = `🪓 Топор: <span style="color:${this.playerHasPickaxe ? 'gold' : '#666'}">${this.playerHasPickaxe ? 'Є' : 'Немає'}</span>`;
    
    if (!document.getElementById('knifeIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const knifeDiv = document.createElement('div');
      knifeDiv.className = 'stat-item'; knifeDiv.id = 'knifeIndicator';
      statsBar.appendChild(knifeDiv);
    }
    document.getElementById('knifeIndicator').innerHTML = `🔪 Ніж: <span style="color:${this.playerHasKnife ? '#33cc33' : '#666'}">${this.playerHasKnife ? `${6 - this.playerKnifeUses}/6` : 'Немає'}</span>`;
    
    if (!document.getElementById('mineIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const mineDiv = document.createElement('div');
      mineDiv.className = 'stat-item'; mineDiv.id = 'mineIndicator';
      statsBar.appendChild(mineDiv);
    }
    document.getElementById('mineIndicator').innerHTML = `💣 Міни: <span style="color:${this.playerMines > 0 ? '#ff2222' : '#666'}">${this.playerMines}</span>`;
    
    if (!document.getElementById('mineDetectorIndicator')) {
      const statsBar = document.getElementById('statsBar');
      const mineDetectorDiv = document.createElement('div');
      mineDetectorDiv.className = 'stat-item'; mineDetectorDiv.id = 'mineDetectorIndicator';
      statsBar.appendChild(mineDetectorDiv);
    }
    document.getElementById('mineDetectorIndicator').innerHTML = `🧰 Детектор мін: <span style="color:${this.playerMineDetectorUses > 0 ? '#33cc33' : '#666'}">${this.playerMineDetectorUses > 0 ? this.playerMineDetectorUses : 'Немає'}</span>`;
  }

  updateStatus(status) {
    const statusMap = {
      'ready': { text: 'Готов до виживання', class: 'status-ready' },
      'playing': { text: 'Виживає...', class: 'status-playing' },
      'finished': { text: 'Загинув!', class: 'status-finished ' }
    };
    const statusInfo = statusMap[status];
    if (statusInfo) {
      this.playerStatusEl.textContent = statusInfo.text;
      this.playerStatusEl.className = `player-status ${statusInfo.class}`;
    }
  }

  togglePause() {
    this.isPaused = !this.isPaused;
    this.pauseBtn.textContent = this.isPaused ? '▶️ Продовжити' : '⏸️ Пауза';
    if (this.isPaused) { this.updateStatus('ready'); this.pauseTime = Date.now(); } 
    else { this.updateStatus('playing'); this.startTime += Date.now() - this.pauseTime; }
  }

  endGame(survived) {
    this.isGameActive = false;
    this.clearAllIntervals();
    if (survived) {
      this.winnerText.textContent = '🏆 ПЕРЕМОГА!';
      this.winnerMessage.textContent = `Вітаємо! Ви знищили всіх зомбі та знайшли вихід!\nЧас виживання: ${Math.floor(this.survivalTime / 60)}:${(this.survivalTime % 60).toString().padStart(2, '0')}\nЗнищено зомбі: ${this.zombiesKilled}\nДосягнутий рівень: ${this.playerLevel}`;
      if (this.audioWin) { this.audioWin.currentTime = 0; this.audioWin.play(); }
    } else {
      this.winnerText.textContent = '💀 ЗАГИНУВ!';
      this.winnerMessage.textContent = `Ви не вижили в зомбі-апокаліпсисі!\nЧас виживання: ${Math.floor(this.survivalTime / 60)}:${(this.survivalTime % 60).toString().padStart(2, '0')}\nЗнищено зомбі: ${this.zombiesKilled}\nДосягнутий рівень: ${this.playerLevel}`;
      if (this.audioPlayerDeath) { this.audioPlayerDeath.currentTime = 0; this.audioPlayerDeath.play(); }
      if (this.audioLose) { this.audioLose.currentTime = 0; this.audioLose.play(); }
    }
    this.winnerOverlay.style.display = 'flex';
    this.pauseBtn.disabled = true;
  }

  showEventNotification(message) {
    const existingNotification = document.querySelector('.event-notification');
    if (existingNotification) existingNotification.remove();
    const notification = document.createElement('div');
    notification.className = 'event-notification';
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
      if (notification.parentNode) {
        notification.style.animation = 'fadeOut 0.5s ease-out';
        setTimeout(() => { if (notification.parentNode) notification.remove(); }, 500);
      }
    }, 3000);
  }

  startRandomMazeEvents() { this.scheduleNextRandomEvent(); }

  scheduleNextRandomEvent() {
    if (!this.isGameActive || this.isPaused) return;
    const delay = 1000 + Math.random() * 119000;
    this.eventInterval = setTimeout(() => {
        if (!this.isGameActive || this.isPaused) return;
        this.randomMazeEvent();
        this.scheduleNextRandomEvent();
    }, delay);
  }

  randomMazeEvent() {
    const isAdd = Math.random() < 0.5;
    const size = this.size;
    const forbiddenSet = new Set();
    forbiddenSet.add(this.playerPos[0] + ',' + this.playerPos[1]);
    this.zombies.forEach(z => forbiddenSet.add(z.pos[0] + ',' + z.pos[1]));
    if (this.exitVisible && this.exitPos) forbiddenSet.add(this.exitPos[0] + ',' + this.exitPos[1]);
    if (this.ammoVisible && this.ammoPos) forbiddenSet.add(this.ammoPos[0] + ',' + this.ammoPos[1]);
    if (this.healthVisible && this.healthPos) forbiddenSet.add(this.healthPos[0] + ',' + this.healthPos[1]);
    if (this.shieldVisible && this.shieldPos) forbiddenSet.add(this.shieldPos[0] + ',' + this.shieldPos[1]);
    if (this.pickaxeVisible && this.pickaxePos) forbiddenSet.add(this.pickaxePos[0] + ',' + this.pickaxePos[1]);
    if (this.knifeVisible && this.knifePos) forbiddenSet.add(this.knifePos[0] + ',' + this.knifePos[1]);
    this.safeZones.forEach(sz => forbiddenSet.add(sz[0] + ',' + sz[1]));
    forbiddenSet.add('1,1');

    let wallChanged = false;
    for (let attempt = 0; attempt < 100; attempt++) {
        const row = Math.floor(Math.random() * (size - 2)) + 1;
        const col = Math.floor(Math.random() * (size - 2)) + 1;
        const key = row + ',' + col;
        if (forbiddenSet.has(key)) continue;
        if (isAdd && this.maze[row][col] === 0) {
            this.maze[row][col] = 1; this.showEventNotification('🧱 З\'явилася нова стіна!'); wallChanged = true; break;
        } else if (!isAdd && this.maze[row][col] === 1) {
            this.maze[row][col] = 0; this.showEventNotification('🕳️ Стіна зникла!'); wallChanged = true; break;
        }
    }
    if (wallChanged) {
        this.zombies.forEach(zombie => { zombie.path = []; zombie.pathIndex = 0; });
        this.renderMaze();
    }
  }

  checkMinesExplosion() {
    for (let i = this.activeMines.length - 1; i >= 0; i--) {
        const mine = this.activeMines[i];
        // Міни гравця шкодять тільки зомбі
        if (mine.placedBy === 'player') {
            const zombieIndex = this.zombies.findIndex(z => z.pos[0] === mine.pos[0] && z.pos[1] === mine.pos[1]);
            if (zombieIndex !== -1) {
                const zombie = this.zombies[zombieIndex];
                const mineDamage = Math.floor(Math.random() * 5) + 1;
                zombie.health -= mineDamage;
                zombie.stunnedUntil = Date.now() + 1000;
                if (zombie.health <= 0) {
                    this.zombies.splice(zombieIndex, 1);
                    this.zombiesKilled++;
                } else {
                    // Повідомлення про поранення зомбі міною прибрано
                }
                if (this.audioMineExplosion) { this.audioMineExplosion.currentTime = 0; this.audioMineExplosion.play(); }
                this.activeMines.splice(i, 1);
                this.renderMaze();
                this.updateStats();
                if (this.zombies.length === 0 && !this.exitVisible) {
                    this.spawnExit();
                    this.showEventNotification('🏆 Всі зомбі знищені! Знайдіть вихід!');
                }
            }
        }
    }
  }
  
  tryPlaceMine() {
    if (this.playerMines > 0) {
      const [row, col] = this.playerPos;
      const isInSafeZone = this.safeZones.some(sz => sz[0] === row && sz[1] === col);
      const isStart = row === 1 && col === 1;
      const isZombieOnPlayer = this.zombies.some(z => z.pos[0] === row && z.pos[1] === col);
      if (this.maze[row][col] === 0 && !this.activeMines.some(m => m.pos[0] === row && m.pos[1] === col) && !isInSafeZone && !isStart && !isZombieOnPlayer) {
        this.activeMines.push({pos: [row, col], placedAt: Date.now(), placedBy: 'player'});
        this.playerMines--;
        this.updateStats();
        if (this.audioMinePlace) { this.audioMinePlace.currentTime = 0; this.audioMinePlace.play(); }
        this.renderMaze();
      } else if (isZombieOnPlayer) {
        this.showEventNotification('❌ Не можна ставити міну, коли на клітинці є зомбі!');
      } else {
        this.showEventNotification('❌ Неможливо встановити міну тут!');
      }
    } else {
      this.showEventNotification('❌ У вас немає мін!');
    }
  }

  tryPlaceZombieMine(zombie) {
    if (zombie.inventory.mines > 0) {
        const [row, col] = zombie.pos;
        const canPlace = this.maze[row][col] === 0 &&
            !this.activeMines.some(m => m.pos[0] === row && m.pos[1] === col) &&
            !(this.playerPos[0] === row && this.playerPos[1] === col) &&
            !this.safeZones.some(sz => sz[0] === row && sz[1] === col);

        if (canPlace) {
            this.activeMines.push({ pos: [row, col], placedAt: Date.now(), placedBy: 'zombie' });
            zombie.inventory.mines--;
            this.showEventNotification('💣 Зомбі встановив міну!');
            if (this.audioMinePlace) { this.audioMinePlace.currentTime = 0; this.audioMinePlace.play(); }
            this.renderMaze();
        }
    }
  }

  checkPlayerMineExplosion() {
    for (let i = this.activeMines.length - 1; i >= 0; i--) {
      const mine = this.activeMines[i];
      if (this.playerPos[0] === mine.pos[0] && this.playerPos[1] === mine.pos[1]) {
        // Гравець підривається на будь-якій міні, якщо пройшло більше 0.5 сек з моменту встановлення
        if (Date.now() - mine.placedAt < 500) continue;
        
        this.activeMines.splice(i, 1);
        const damage = mine.placedBy === 'zombie' ? 50 : Math.floor(Math.random() * 200) + 1; // Міни зомбі менш потужні
        if (this.playerShield > 0) {
          const shieldDamage = Math.min(this.playerShield, damage);
          this.playerShield -= shieldDamage;
          this.playerHealth -= (damage - shieldDamage);
        } else {
          this.playerHealth -= damage;
        }
        this.playerBlockedUntil = Date.now() + 3000;
        this.updateStats();
        this.showEventNotification(`💥 Ви підірвалися на міні! -${damage} HP`);
        if (this.audioMineExplosion) { this.audioMineExplosion.currentTime = 0; this.audioMineExplosion.play(); }
        this.renderMaze();
        if (this.playerHealth <= 0) {
          this.endGame(false);
        }
      }
    }
  }

  tryDefuseMine() {
    if (this.playerMineDetectorUses <= 0) {
      this.showEventNotification('❌ У вас немає мінного детектора!');
      return;
    }
    // Можна розмінувати міну зомбі або свою міну на сусідній клітинці
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    let defused = false;
    let defusedMineType = '';
    
    for (const [dr,dc] of dirs) {
      const r = this.playerPos[0] + dr;
      const c = this.playerPos[1] + dc;
      const mineIdx = this.activeMines.findIndex(m => m.pos[0] === r && m.pos[1] === c);
      
      if (mineIdx !== -1) {
        const mine = this.activeMines[mineIdx];
        this.activeMines.splice(mineIdx, 1);
        this.playerMineDetectorUses--;
        
        if (mine.placedBy === 'zombie') {
          this.showEventNotification('🧰 Ви розмінували міну зомбі!');
        } else {
          this.showEventNotification('🧰 Ви розмінували свою міну!');
        }
        
        this.renderMaze();
        this.updateStats();
        defused = true;
        break;
      }
    }
    
    if (!defused) {
      this.showEventNotification('❌ Поруч немає мін для розмінування!');
    }
    
    if (this.audioMineDefuse) { this.audioMineDefuse.currentTime = 0; this.audioMineDefuse.play(); }
  }
}

// Запуск гри
window.addEventListener('DOMContentLoaded', () => {
  window.zombieGame = new ZombieApocalypseGame();
});
</script>

<nav class="menu-nav">
  <a href="index.html" class="menu-btn">Головна</a>
  <a href="global.html" class="menu-btn">GLOBAL</a>
  <a href="test-mode.html" class="menu-btn">test-mode</a>
  <a href="test-mode-experimental.html" class="menu-btn">test-mode-experimental</a>
  <a href="npc-ai.html" class="menu-btn">npc-ai</a>
  <a href="npc-ai-mini.html" class="menu-btn">npc-ai-mini</a>
  <a href="standings.html" class="menu-btn">Турнірна таблиця</a>
</nav>

<div class="instructions">
  <h3>🧟‍♂️ Зомбі-Апокаліпсис: Лабіринт Виживання</h3>
  <p><strong>🎯 Ціль:</strong> Знищити всіх зомбі, щоб з'явився червоний квадрат (вихід), потім дістатися до нього!</p>
  <p><strong>🎮 Керування:</strong> Стрілки ←↑↓→ або WASD для руху, Пробіл для атаки (тільки коли стоїте), E для топора, X для встановлення міни, R для розмінування міни</p>
  <p><strong>📋 Правила:</strong> Зелений квадрат - старт. Зомбі рухаються за допомогою A* алгоритму. Збирайте патрони, здоров'я, щити, топори та ножі. Безпечні зони тимчасово захищають від зомбі!</p>
  <p><strong>🧟‍♂️ Зомбі:</strong> З'являються ТІЛЬКИ при контакті різних типів. Типи змінюються кожні 10 секунд. <strong>УВАГА:</strong> Зомбі тепер можуть підбирати предмети, стріляти, ставити міни та руйнувати стіни!</p>
  <p><strong>💪 Здоров'я зомбі:</strong> Звичайний (2 HP), Швидкий (3 HP), Бос (5 HP)</p>
  <p><strong>🪓 Топор:</strong> Дозволяє прорубувати стіни для створення нових шляхів!</p>
  <p><strong>🔪 Ніж:</strong> Потрібен для ближнього бою! Без ножа неможливо атакувати зомбі на тій самій клітинці.</p>
  <p><strong>🔫 Бойова система:</strong> Ближній бій ножем (не витрачає патрони) або стрільба (витрачає патрони). Без ножа - неможливо атакувати в ближньому бою!</p>
  <p><strong>🏆 Перемога:</strong> Спочатку знищіть ВСІХ зомбі → з'явиться червоний квадрат у випадковому куті → дістаньтеся до нього!</p>
  <p><strong>🎮 Рівні складності:</strong> Легкий, Середній, Важкий, Кошмар</p>
</div>
</body>
</html>