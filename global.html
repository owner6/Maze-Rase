<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=1200">
  <title>–ì–æ–Ω–∫–∞ –≤ –õ–∞–±–∏—Ä–∏–Ω—Ç–µ: –û–±—â–∞—è –∫–∞—Ä—Ç–∞</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    .header { text-align: center; margin-bottom: 0px; }
    .header h1 { font-size: 2 em; margin-bottom: 0px; }
    .controls { display: flex; gap: 15px; margin-bottom: 5px; }
    .btn {
      padding: 5px 15px;
      background: linear-gradient(45deg, #ff6b6b, #ee5a24);
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
    .btn:disabled { background: #666; cursor: not-allowed; transform: none; }
    .maze-container {
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 5px;
      overflow: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      margin-bottom: 20px;
      background: #2c3e50;
      max-width: 1100px;
      max-height: 1100px;
    }
    .maze {
      display: grid;
      background: #2c3e50;
    }
    .cell {
      width: 10px;
      height: 10px;
      border: 0.5px solid rgba(52, 73, 94, 0.3);
      box-sizing: border-box;
    }
    .wall { background: #34495e; }
    .path { background: #ecf0f1; }
    .start { background: #27ae60; }
    .end { background: #e74c3c; }
    .player { background: #3498db; box-shadow: 0 0 10px #3498db; }
    .computer { background: #e67e22; box-shadow: 0 0 10px #e67e22; }
    .timer {
      font-size: 2 em;
      margin: 0px 0;
      padding: 10px 10px;
      background: rgba(0,0,0,0.3);
      border-radius: 15px;
    }
    .status-bar { display: flex; gap: 30px; margin-bottom: 10px; }
    .player-status, .computer-status {
      font-size: 1 em;
      padding: 3px 10px;
      border-radius: 15px;
      display: inline-block;
      background: rgba(52, 152, 219, 0.8);
      transition: background 0.5s ease;
    }
    .computer-status { background: rgba(241, 196, 15, 0.8); }
    .winner-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 1000;
    }
    .winner-modal {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 40px; border-radius: 20px; text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      animation: modalAppear 0.5s ease-out;
    }
    @keyframes modalAppear { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    .winner-text { font-size: 2.5em; margin-bottom: 20px; }
    .instructions { margin-top: 20px; text-align: center; max-width: 700px; background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; }
    .ghost { border-radius: 50%; }
    .ghost-pink { background: #ff79c6 !important; box-shadow: 0 0 8px #ff79c6; }
    .ghost-cyan { background: #8be9fd !important; box-shadow: 0 0 8px #8be9fd; }
    .ghost-orange { background: #ffb86c !important; box-shadow: 0 0 8px #ffb86c; }
    .ghost-purple {
  background: #bd93f9 !important;
  box-shadow: 0 0 8px #bd93f9;
}
.ghost-green {
  background: #50fa7b !important;
  box-shadow: 0 0 8px #50fa7b;
}
  </style>
</head>
<body>
<div class="header">
</div>
<div class="controls">
  <button class="btn" id="newGameBtn">üéÆ –ù–æ–≤–∞—è –∏–≥—Ä–∞</button>
  <button class="btn" id="pauseBtn" disabled>‚è∏Ô∏è –ü–∞—É–∑–∞</button>
  <button class="btn" id="helpBtn">‚ùì –ü–æ–º–æ—â—å</button>
</div>
<div class="status-bar">
  <div class="player-status" id="playerStatus">–ò–≥—Ä–æ–∫: –ì–æ—Ç–æ–≤</div>
  <div class="computer-status" id="computerStatus">–ö–æ–º–ø—å—é—Ç–µ—Ä: –ì–æ—Ç–æ–≤</div>
</div>
<div class="timer" id="timer">–í—Ä–µ–º—è: 00:00</div>
<div class="maze-container">
  <div class="maze" id="maze"></div>
</div>
<div class="winner-overlay" id="winnerOverlay">
  <div class="winner-modal">
    <div class="winner-text" id="winnerText">üèÜ –ü–û–ë–ï–î–ê!</div>
    <p id="winnerMessage">–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø–æ–±–µ–¥–æ–π!</p>
    <button class="btn" id="playAgainBtn">üîÑ –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
  </div>
</div>
<div class="instructions">
  <h3>üéØ –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏</h3>
  <p><strong>–¶–µ–ª—å:</strong> –°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –≤—Å–µ—Ö –∑–∞–ª–æ–∂–Ω–∏–∫–æ–≤ (üë§), –∑–∞—Ç–µ–º –¥–æ–±–µ—Ä–∏—Ç–µ—Å—å –¥–æ –≤—ã—Ö–æ–¥–∞ (–∫—Ä–∞—Å–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç)!</p>
  <p><strong>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç—Ä–µ–ª–∫–∏ ‚Üê‚Üë‚Üì‚Üí –∏–ª–∏ WASD –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è</p>
  <p><strong>–ü—Ä–∞–≤–∏–ª–∞:</strong> –ó–µ–ª–µ–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç - —Å—Ç–∞—Ä—Ç. –ù–µ–ª—å–∑—è –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ —Å—Ç–µ–Ω—ã!</p>
</div>
<script>
class MazeGenerator {
  constructor(size) {
    this.size = size;
    this.maze = [];
    this.end = null; // –ò–ó–ú–ï–ù–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω–æ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—ã—Ö–æ–¥–∞
    this.generate();
  }
  generate() {
    this.maze = Array(this.size).fill().map(() => Array(this.size).fill(1));
    const stack = [];
    const start = [Math.floor(this.size/2), Math.floor(this.size/2)];
    this.maze[start[0]][start[1]] = 0;
    stack.push(start);
    while (stack.length > 0) {
      const current = stack[stack.length - 1];
      const neighbors = this.getUnvisitedNeighbors(current);
      if (neighbors.length > 0) {
        const next = neighbors[Math.floor(Math.random() * neighbors.length)];
        this.removeWall(current, next);
        this.maze[next[0]][next[1]] = 0;
        stack.push(next);
      } else {
        stack.pop();
      }
    }
    // –ò–ó–ú–ï–ù–ï–ù–û: –§–∏–Ω–∏—à (–≤—ã—Ö–æ–¥) ‚Äî –æ–¥–∏–Ω –∏–∑ —É–≥–ª–æ–≤ (—Ä–∞–Ω–¥–æ–º–Ω–æ)
    const corners = [
      [1, 1],
      [1, this.size-2],
      [this.size-2, 1],
      [this.size-2, this.size-2]
    ];
    this.end = corners[Math.floor(Math.random()*corners.length)];
    this.maze[this.end[0]][this.end[1]] = 0; // –î–µ–ª–∞–µ–º –∫–ª–µ—Ç–∫—É –≤—ã—Ö–æ–¥–∞ –ø—Ä–æ—Ö–æ–¥–∏–º–æ–π
  }
  getUnvisitedNeighbors([row, col]) {
    const neighbors = [];
    const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
    for (const [dr, dc] of directions) {
      const newRow = row + dr;
      const newCol = col + dc;
      if (newRow > 0 && newRow < this.size - 1 && newCol > 0 && newCol < this.size - 1 && this.maze[newRow][newCol] === 1) {
        neighbors.push([newRow, newCol]);
      }
    }
    return neighbors;
  }
  removeWall([row1, col1], [row2, col2]) {
    const wallRow = (row1 + row2) / 2;
    const wallCol = (col1 + col2) / 2;
    this.maze[wallRow][wallCol] = 0;
  }
}
class GlobalMazeGame {
  constructor() {
    this.size = 71;
    this.maze = null;
    this.playerPos = null;
    this.endPos = null; // –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–∑–∏—Ü–∏—è –≤—ã—Ö–æ–¥–∞
    this.isGameActive = false;
    this.isPaused = false;
    this.startTime = null;
    this.timerInterval = null;
    this.playerDirection = null;
    this.playerMoveInterval = null;
    this.ghosts = [];
    this.ghostMoveInterval = null;
    this.ghostColorChangeInterval = null;
    this.hostages = [];
    this.hostagesCount = 1;
    this.playerScore = 0;
    this.initializeElements();
    this.setupEventListeners();
  }
  initializeElements() {
    this.mazeEl = document.getElementById('maze');
    this.playerStatusEl = document.getElementById('playerStatus');
    this.computerStatusEl = document.getElementById('computerStatus'); // –ò–ó–ú–ï–ù–ï–ù–û
    this.timerEl = document.getElementById('timer');
    this.winnerOverlay = document.getElementById('winnerOverlay');
    this.winnerText = document.getElementById('winnerText');
    this.winnerMessage = document.getElementById('winnerMessage');
    this.newGameBtn = document.getElementById('newGameBtn');
    this.pauseBtn = document.getElementById('pauseBtn');
    this.playAgainBtn = document.getElementById('playAgainBtn');
  }
  setupEventListeners() {
    this.newGameBtn.addEventListener('click', () => this.newGame());
    this.pauseBtn.addEventListener('click', () => this.togglePause());
    this.playAgainBtn.addEventListener('click', () => this.newGame());
    document.getElementById('helpBtn').addEventListener('click', () => {
      alert('üéØ –¶–µ–ª—å: –°–Ω–∞—á–∞–ª–∞ —Å–æ–±–µ—Ä–∏—Ç–µ –≤—Å–µ—Ö –∑–∞–ª–æ–∂–Ω–∏–∫–æ–≤ (üë§), –∑–∞—Ç–µ–º –¥–æ–±–µ—Ä–∏—Ç–µ—Å—å –¥–æ –≤—ã—Ö–æ–¥–∞ (–∫—Ä–∞—Å–Ω—ã–π –∫–≤–∞–¥—Ä–∞—Ç)!\n\nüéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:\n‚Ä¢ –°—Ç—Ä–µ–ª–∫–∏ ‚Üê‚Üë‚Üì‚Üí\n‚Ä¢ –ò–ª–∏ –∫–ª–∞–≤–∏—à–∏ WASD');
    });
    document.addEventListener('keydown', (e) => this.handleKeyPress(e));
  }
  clearAllIntervals() {
    if (this.timerInterval) { clearInterval(this.timerInterval); this.timerInterval = null; }
    if (this.playerMoveInterval) { clearInterval(this.playerMoveInterval); this.playerMoveInterval = null; }
    if (this.ghostMoveInterval) { clearInterval(this.ghostMoveInterval); this.ghostMoveInterval = null; }
    if (this.ghostColorChangeInterval) { clearInterval(this.ghostColorChangeInterval); this.ghostColorChangeInterval = null; }
  }
  newGame() {
    this.clearAllIntervals();
    this.isGameActive = true;
    this.isPaused = false;
    this.startTime = Date.now();
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ª–∞–±–∏—Ä–∏–Ω—Ç
    const generator = new MazeGenerator(this.size);
    this.maze = generator.maze.map(row => [...row]);
    this.endPos = generator.end; // –ò–ó–ú–ï–ù–ï–ù–û: –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≤—ã—Ö–æ–¥–∞

    // –°—Ç–∞—Ä—Ç–æ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –∏–≥—Ä–æ–∫–∞
    const center = Math.floor(this.size/2);
    this.playerPos = [center, center];
    // –†–∞–∑–º–µ—â–∞–µ–º –∑–∞–ª–æ–∂–Ω–∏–∫–æ–≤
    this.hostages = [];
    let placed = 0;
    while (placed < this.hostagesCount) {
      const r = Math.floor(Math.random() * (this.size-2)) + 1;
      const c = Math.floor(Math.random() * (this.size-2)) + 1;
      if (
        this.maze[r][c] === 0 &&
        !this.hostages.some(h => h[0] === r && h[1] === c) &&
        !(r === this.playerPos[0] && c === this.playerPos[1]) &&
        !(r === this.endPos[0] && c === this.endPos[1]) // –ù–µ —Å—Ç–∞–≤–∏–º –∑–∞–ª–æ–∂–Ω–∏–∫–∞ –Ω–∞ –≤—ã—Ö–æ–¥
      ) {
        this.hostages.push([r, c]);
        placed++;
      }
    }
    this.playerScore = 0;
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–∑—Ä–∞–∫–æ–≤
    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
    const ghostColors = ['ghost-pink', 'ghost-cyan', 'ghost-orange', 'ghost-purple', 'ghost-green'];
    this.ghosts = [];

    for (const color of ghostColors) {
      const count = Math.floor(Math.random() * 2) + 1;
      for (let i = 0; i < count; i++) {
        this.ghosts.push({
          pos: this.getRandomEmptyPosition(),
          state: 'patrolling',
          direction: directions[Math.floor(Math.random() * directions.length)],
          path: [],
          pathIndex: 0,
          colorClass: color
        });
      }
    }

    // –ò–ó–ú–ï–ù–ï–ù–û: –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å
    this.computerStatusEl.textContent = '–ö–æ–º–ø—å—é—Ç–µ—Ä: –ì–æ—Ç–æ–≤';
    this.computerStatusEl.style.background = 'rgba(241, 196, 15, 0.8)';

    this.renderMaze();
    this.updateStatus('playing');
    this.startTimer();
    this.startPlayerAutoMove();
    this.startGhostAI();
    this.startGhostColorChange();
    this.newGameBtn.textContent = 'üîÑ –ù–æ–≤–∞—è –∏–≥—Ä–∞';
    this.pauseBtn.disabled = false;
    this.winnerOverlay.style.display = 'none';
  }
  renderMaze() {
    this.mazeEl.innerHTML = '';
    this.mazeEl.style.gridTemplateColumns = `repeat(${this.size}, 1fr)`;
    for (let row = 0; row < this.size; row++) {
      for (let col = 0; col < this.size; col++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        if (this.maze[row][col] === 1) cell.classList.add('wall');
        else cell.classList.add('path');
        
        // –ò–ó–ú–ï–ù–ï–ù–û: –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –≤—ã—Ö–æ–¥, –µ—Å–ª–∏ –≤—Å–µ –∑–∞–ª–æ–∂–Ω–∏–∫–∏ —Å–ø–∞—Å–µ–Ω—ã
        if (this.hostages.length === 0 && row === this.endPos[0] && col === this.endPos[1]) {
            cell.classList.add('end');
        }

        if (row === this.playerPos[0] && col === this.playerPos[1]) cell.classList.add('player');
        
        for (const ghost of this.ghosts) {
          if (row === ghost.pos[0] && col === ghost.pos[1]) {
            cell.classList.add('ghost', ghost.colorClass);
          }
        }
        
        if (this.hostages.some(h => h[0] === row && h[1] === col)) {
          cell.style.background = '#e74c3c';
          cell.innerHTML = '<span style="font-size:12px; color:white;">üë§</span>';
        }
        
        if (row === Math.floor(this.size/2) && col === Math.floor(this.size/2)) cell.classList.add('start');
        
        this.mazeEl.appendChild(cell);
      }
    }
    
    if (!this.scoreBar) {
      this.scoreBar = document.createElement('div');
      this.scoreBar.style.margin = '10px 0 20px 0';
      this.scoreBar.style.fontSize = '1.2em';
      this.mazeEl.parentElement.insertBefore(this.scoreBar, this.mazeEl);
    }
    const ghostCount = this.ghosts.length;
    this.scoreBar.innerHTML = `
      –ó–∞–ª–æ–∂–Ω–∏–∫–∏: <span style='color:#3498db'>${this.playerScore}/${this.hostagesCount}</span> |
      –ü—Ä–∏–∑—Ä–∞–∫–∏: <span style='color:#ffb86c'>${ghostCount}</span>
    `;
  }
  handleKeyPress(e) {
    if (!this.isGameActive || this.isPaused) return;
    const keyMap = {
      'ArrowUp': [-1, 0], 'KeyW': [-1, 0],
      'ArrowDown': [1, 0], 'KeyS': [1, 0],
      'ArrowLeft': [0, -1], 'KeyA': [0, -1],
      'ArrowRight': [0, 1], 'KeyD': [0, 1]
    };
    const direction = keyMap[e.code];
    if (direction) {
      e.preventDefault();
      this.playerDirection = direction;
    }
  }
  startPlayerAutoMove() {
    if (this.playerMoveInterval) { clearInterval(this.playerMoveInterval); this.playerMoveInterval = null; }
    this.playerMoveInterval = setInterval(() => {
      if (!this.isGameActive || this.isPaused || !this.playerDirection) return;
      const newRow = this.playerPos[0] + this.playerDirection[0];
      const newCol = this.playerPos[1] + this.playerDirection[1];
      if (this.isValidMove(newRow, newCol)) {
        this.playerPos = [newRow, newCol];
        this.checkHostagePickup();
        this.renderMaze();
        this.checkWin();
      }
    }, 60);
  }
  isValidMove(row, col) {
    return row >= 0 && row < this.size && col >= 0 && col < this.size && this.maze[row][col] === 0;
  }
  checkHostagePickup() {
    for (let i = 0; i < this.hostages.length; i++) {
      if (this.hostages[i][0] === this.playerPos[0] && this.hostages[i][1] === this.playerPos[1]) {
        this.hostages.splice(i, 1);
        this.playerScore++;
        // –ò–ó–ú–ï–ù–ï–ù–û: –ï—Å–ª–∏ —ç—Ç–æ –±—ã–ª –ø–æ—Å–ª–µ–¥–Ω–∏–π –∑–∞–ª–æ–∂–Ω–∏–∫, –¥–∞–µ–º –Ω–æ–≤—É—é –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
        if (this.hostages.length === 0) {
            this.computerStatusEl.textContent = '–í—Å–µ —Å–ø–∞—Å–µ–Ω—ã! –ò–¥–∏—Ç–µ –∫ –≤—ã—Ö–æ–¥—É!';
            this.computerStatusEl.style.background = 'rgba(46, 204, 113, 0.8)'; // –ó–µ–ª–µ–Ω—ã–π
        }
        break;
      }
    }
  }
  // –ò–ó–ú–ï–ù–ï–ù–û: –ù–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –ø–æ–±–µ–¥—ã
  checkWin() {
    if (this.hostages.length === 0 && this.playerPos[0] === this.endPos[0] && this.playerPos[1] === this.endPos[1]) {
      this.endGame();
    }
  }
  endGame() {
    this.isGameActive = false;
    this.clearAllIntervals();
    this.updateStatus('finished');
    setTimeout(() => {
      // –ò–ó–ú–ï–ù–ï–ù–û: –û–±–Ω–æ–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–±–µ–¥–µ
      this.winnerText.textContent = 'üèÜ –ü–û–ë–ï–î–ê!';
      this.winnerMessage.textContent = `–í—ã —Å–ø–∞—Å–ª–∏ –≤—Å–µ—Ö –∑–∞–ª–æ–∂–Ω–∏–∫–æ–≤ –∏ –Ω–∞—à–ª–∏ –≤—ã—Ö–æ–¥! –í–∞—à —Å—á—ë—Ç: ${this.playerScore}`;
      this.winnerOverlay.style.display = 'flex';
    }, 500);
    this.pauseBtn.disabled = true;
  }
  updateStatus(status) {
    if (status === 'playing') {
      this.playerStatusEl.textContent = '–ò–≥—Ä–æ–∫: –í –∏–≥—Ä–µ...';
    } else if (status === 'finished') {
      this.playerStatusEl.textContent = '–ò–≥—Ä–æ–∫: –§–∏–Ω–∏—à!';
    } else {
      this.playerStatusEl.textContent = '–ò–≥—Ä–æ–∫: –ì–æ—Ç–æ–≤';
    }
  }
  startTimer() {
    if (this.timerInterval) { clearInterval(this.timerInterval); this.timerInterval = null; }
    this.timerInterval = setInterval(() => {
      if (!this.isPaused && this.isGameActive) {
        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        this.timerEl.textContent = `–í—Ä–µ–º—è: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }, 1000);
  }
  togglePause() {
    this.isPaused = !this.isPaused;
    this.pauseBtn.textContent = this.isPaused ? '‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '‚è∏Ô∏è –ü–∞—É–∑–∞';
    if (this.isPaused) {
      this.updateStatus('–ì–æ—Ç–æ–≤');
    } else {
      this.updateStatus('playing');
      this.startTime += Date.now() - this.pauseTime;
    }
    if (this.isPaused) {
      this.pauseTime = Date.now();
    }
  }
  startGhostAI() {
    if (this.ghostMoveInterval) { clearInterval(this.ghostMoveInterval); this.ghostMoveInterval = null; }
    setTimeout(() => {
      if (!this.isGameActive) return;
      if (this.ghostMoveInterval) { clearInterval(this.ghostMoveInterval); this.ghostMoveInterval = null; }
      this.ghostMoveInterval = setInterval(() => {
        if (!this.isGameActive || this.isPaused) return;
        this.moveGhosts();
      }, 120);
    }, 2000);
  }
  moveGhosts() {
    this.moveGhostsGeneric(this.ghosts, this.maze, this.playerPos, () => this.checkCollision());
  };
  moveGhostsGeneric(ghosts, maze, targetPos, collisionCallback) {
  for (const ghost of ghosts) {
    if (this.canSeeTarget(ghost, maze, targetPos)) {
      ghost.state = 'chasing';
    } else {
      ghost.state = 'patrolling';
    }
    if (ghost.state === 'chasing') {
      if (!ghost.path || ghost.pathIndex >= ghost.path.length || Math.random() < 0.1) {
        ghost.path = this.findPathAStar(ghost.pos, targetPos);
        ghost.pathIndex = 1;
      }
      if (ghost.path && ghost.pathIndex < ghost.path.length) {
        ghost.pos = ghost.path[ghost.pathIndex];
        ghost.pathIndex++;
      }
    } else {
      const possibleDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
      const prevDirection = ghost.direction;
      const reverseDirection = prevDirection ? [-prevDirection[0], -prevDirection[1]] : null;
      let validDirections = possibleDirections.filter(dir => {
        const checkPos = [ghost.pos[0] + dir[0], ghost.pos[1] + dir[1]];
        if (reverseDirection && dir[0] === reverseDirection[0] && dir[1] === reverseDirection[1]) return false;
        return this.isValidMove(checkPos[0], checkPos[1]);
      });
      if (validDirections.length === 0 && reverseDirection) {
        const backPos = [ghost.pos[0] + reverseDirection[0], ghost.pos[1] + reverseDirection[1]];
        if (this.isValidMove(backPos[0], backPos[1])) {
          validDirections = [reverseDirection];
        }
      }
      if (validDirections.length > 1 && Math.random() < 0.3) {
        ghost.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
      } else if (validDirections.length > 0) {
        const nextPos = [ghost.pos[0] + (ghost.direction ? ghost.direction[0] : 0), ghost.pos[1] + (ghost.direction ? ghost.direction[1] : 0)];
        if (!ghost.direction || !this.isValidMove(nextPos[0], nextPos[1])) {
          ghost.direction = validDirections[Math.floor(Math.random() * validDirections.length)];
        }
      }
      if (ghost.direction) {
        ghost.pos = [ghost.pos[0] + ghost.direction[0], ghost.pos[1] + ghost.direction[1]];
      }
    }
  }
  collisionCallback();
  this.checkGhostInteractions();
  this.renderMaze();
}
  canSeeTarget(ghost, maze, targetPos) {
    const [gRow, gCol] = ghost.pos;
    const [tRow, tCol] = targetPos;
    const lineOfSightDistance = 15;
    if (gRow === tRow && Math.abs(gCol - tCol) < lineOfSightDistance) {
      const start = Math.min(gCol, tCol);
      const end = Math.max(gCol, tCol);
      let wallFound = false;
      for (let i = start + 1; i < end; i++) {
        if (maze[gRow][i] === 1) { wallFound = true; break; }
      }
      if (!wallFound) return true;
    }
    if (gCol === tCol && Math.abs(gRow - tRow) < lineOfSightDistance) {
      const start = Math.min(gRow, tRow);
      const end = Math.max(gRow, tRow);
      let wallFound = false;
      for (let i = start + 1; i < end; i++) {
        if (maze[i][gCol] === 1) { wallFound = true; break; }
      }
      if (!wallFound) return true;
    }
    return false;
  }
  getRandomEmptyPosition() {
    let row, col;
    do {
      row = Math.floor(Math.random() * (this.size - 2)) + 1;
      col = Math.floor(Math.random() * (this.size - 2)) + 1;
    } while (
      this.maze[row][col] === 1 ||
      (row === this.playerPos[0] && col === this.playerPos[1])
    );
    return [row, col];
  }
  findPathAStar(start, goal) {
    const openSet = [start];
    const cameFrom = {};
    const gScore = Array(this.size).fill().map(() => Array(this.size).fill(Infinity));
    const fScore = Array(this.size).fill().map(() => Array(this.size).fill(Infinity));
    gScore[start[0]][start[1]] = 0;
    fScore[start[0]][start[1]] = this.heuristic(start, goal);
    function posToStr(pos) { return pos[0] + ',' + pos[1]; }
    function strToPos(str) { return str.split(',').map(Number); }
    while (openSet.length > 0) {
      let currentIdx = 0;
      for (let i = 1; i < openSet.length; i++) {
        const [r, c] = openSet[i];
        if (fScore[r][c] < fScore[openSet[currentIdx][0]][openSet[currentIdx][1]]) {
          currentIdx = i;
        }
      }
      const current = openSet.splice(currentIdx, 1)[0];
      if (current[0] === goal[0] && current[1] === goal[1]) {
        let path = [goal];
        let currStr = posToStr(goal);
        while (cameFrom[currStr]) {
          currStr = cameFrom[currStr];
          path.push(strToPos(currStr));
        }
        path.reverse();
        return path;
      }
      const directions = [[-1,0],[1,0],[0,-1],[0,1]];
      for (const [dr, dc] of directions) {
        const nr = current[0] + dr, nc = current[1] + dc;
        if (nr >= 0 && nr < this.size && nc >= 0 && nc < this.size && this.maze[nr][nc] === 0) {
          const tentative_gScore = gScore[current[0]][current[1]] + 1;
          if (tentative_gScore < gScore[nr][nc]) {
            cameFrom[posToStr([nr, nc])] = posToStr(current);
            gScore[nr][nc] = tentative_gScore;
            fScore[nr][nc] = tentative_gScore + this.heuristic([nr, nc], goal);
            if (!openSet.some(([r, c]) => r === nr && c === nc)) {
              openSet.push([nr, nc]);
            }
          }
        }
      }
    }
    return [start];
  }
  heuristic(pos, goal) {
    return Math.abs(pos[0] - goal[0]) + Math.abs(pos[1] - goal[1]);
  }
  checkCollision() {
    for (const ghost of this.ghosts) {
      if (ghost.pos[0] === this.playerPos[0] && ghost.pos[1] === this.playerPos[1]) {
        this.isGameActive = false;
        this.clearAllIntervals();
        this.playerStatusEl.textContent = '–ü–û–ô–ú–ê–ù!';
        this.playerStatusEl.className = 'player-status status-finished';
        setTimeout(() => {
          this.winnerText.textContent = 'üëª –í–ê–° –ü–û–ô–ú–ê–õ–ò!';
          this.winnerMessage.textContent = '–ü—Ä–∏–∑—Ä–∞–∫–∏ –æ–∫–∞–∑–∞–ª–∏—Å—å –ø—Ä–æ–≤–æ—Ä–Ω–µ–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞!';
          this.winnerOverlay.style.display = 'flex';
        }, 500);
        this.pauseBtn.disabled = true;
        return;
      }
    }
  }
  
  // –ó–ê–ú–ï–ù–ò–¢–ï –°–¢–ê–†–£–Æ –§–£–ù–ö–¶–ò–Æ checkGhostInteractions –ù–ê –≠–¢–£:
checkGhostInteractions() {
  const toRemove = new Set();
  const newGhosts = [];
  const minGhosts = 1;
  const maxGhosts = 4047;

  for (let i = 0; i < this.ghosts.length; i++) {
    if (toRemove.has(i)) continue;

    for (let j = i + 1; j < this.ghosts.length; j++) {
      if (toRemove.has(j)) continue;

      const g1 = this.ghosts[i];
      const g2 = this.ghosts[j];

      const isTouching = Math.abs(g1.pos[0] - g2.pos[0]) + Math.abs(g1.pos[1] - g2.pos[1]) <= 1;

      // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ü–≤–µ—Ç–∞ –†–ê–ó–ù–´–ï
      if (isTouching && g1.colorClass !== g2.colorClass) {
        
        // 50% —à–∞–Ω—Å –Ω–∞ —Ä–æ–∂–¥–µ–Ω–∏–µ, 50% –Ω–∞ –≥–∏–±–µ–ª—å
        if (Math.random() < 0.5) {
          // --- –†–û–ñ–î–ï–ù–ò–ï ---
          if (this.ghosts.length + newGhosts.length < maxGhosts) {
            newGhosts.push({
              pos: this.getRandomEmptyPosition(),
              state: 'patrolling',
              direction: [0, 1],
              path: [],
              pathIndex: 0,
              colorClass: this.getRandomColorClass() // –ù–æ–≤—ã–π –ø—Ä–∏–∑—Ä–∞–∫ –ø–æ–ª—É—á–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç
            });
          }
        } else {
          // --- –ì–ò–ë–ï–õ–¨ ---
          if (this.ghosts.length - toRemove.size > minGhosts) {
            // –£–¥–∞–ª—è–µ–º –æ–¥–Ω–æ–≥–æ –∏–∑ –¥–≤—É—Ö —Å—Ç–æ–ª–∫–Ω—É–≤—à–∏—Ö—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º
            toRemove.add(Math.random() < 0.5 ? i : j);
          }
        }
        
        // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥–∞–ª—å–Ω–µ–π—à–∏–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è —ç—Ç–æ–π –ø–∞—Ä—ã –≤ —Ç–µ–∫—É—â–µ–º —Ç–∏–∫–µ
        // –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É –≥–ª–∞–≤–Ω–æ–º—É –ø—Ä–∏–∑—Ä–∞–∫—É (i)
        break; 
      }
    }
  }

  // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏
  this.ghosts = this.ghosts.filter((_, index) => !toRemove.has(index));
  this.ghosts.push(...newGhosts);

  // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –ø–æ–ø—É–ª—è—Ü–∏—è –Ω–µ –≤—ã–º—Ä–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é
  while (this.ghosts.length < minGhosts) {
    this.ghosts.push({
      pos: this.getRandomEmptyPosition(),
      state: 'patrolling',
      direction: [0, 1],
      path: [],
      pathIndex: 0,
      colorClass: this.getRandomColorClass()
    });
  }
}

  getRandomColorClass() {
      const ghostColors = ['ghost-pink', 'ghost-cyan', 'ghost-orange', 'ghost-purple', 'ghost-green'];
      return ghostColors[Math.floor(Math.random() * ghostColors.length)];
  }

  startGhostColorChange() {
      if (this.ghostColorChangeInterval) {
          clearInterval(this.ghostColorChangeInterval);
      }
      this.ghostColorChangeInterval = setInterval(() => {
          if (!this.isGameActive || this.isPaused || this.ghosts.length === 0) {
              return;
          }
          const randomGhostIndex = Math.floor(Math.random() * this.ghosts.length);
          const ghostToChange = this.ghosts[randomGhostIndex];
          ghostToChange.colorClass = this.getRandomColorClass();
          this.renderMaze();
      }, 10000);
  }

}
window.addEventListener('DOMContentLoaded', () => {
  window.globalMazeGame = new GlobalMazeGame();
});
</script>
</body>
</html>